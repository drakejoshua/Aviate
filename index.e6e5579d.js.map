{"mappings":"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","sources":["<anon>","src/script.js","node_modules/jarallax/dist/jarallax.esm.js","node_modules/jarallax/src/defaults.js","node_modules/jarallax/src/utils/global.js","node_modules/jarallax/src/utils/css.js","node_modules/jarallax/src/utils/extend.js","node_modules/jarallax/src/utils/getParents.js","node_modules/jarallax/src/utils/ready.js","node_modules/jarallax/src/utils/isMobile.js","node_modules/jarallax/src/utils/getWindowSize.js","node_modules/jarallax/src/utils/observer.js","node_modules/jarallax/src/core.js","node_modules/jarallax/node_modules/video-worker/dist/video-worker.esm.js","node_modules/jarallax/src/ext-video.js","node_modules/jarallax/src/deprecated/ext-element.js","node_modules/jarallax/src/core.esm.js"],"sourcesContent":["\n      var $parcel$global = globalThis;\n    // import the code dependency( i.e. jarallax )\n/*!\n * Jarallax v2.1.4 (https://github.com/nk-o/jarallax)\n * Copyright 2023 nK <https://nkdev.info>\n * Licensed under MIT (https://github.com/nk-o/jarallax/blob/master/LICENSE)\n */ var $4f4d636ec052f8d7$var$defaults$1 = {\n    // Base parallax options.\n    type: \"scroll\",\n    speed: 0.5,\n    containerClass: \"jarallax-container\",\n    imgSrc: null,\n    imgElement: \".jarallax-img\",\n    imgSize: \"cover\",\n    imgPosition: \"50% 50%\",\n    imgRepeat: \"no-repeat\",\n    keepImg: false,\n    elementInViewport: null,\n    zIndex: -100,\n    disableParallax: false,\n    // Callbacks.\n    onScroll: null,\n    onInit: null,\n    onDestroy: null,\n    onCoverImage: null,\n    // Video options.\n    videoClass: \"jarallax-video\",\n    videoSrc: null,\n    videoStartTime: 0,\n    videoEndTime: 0,\n    videoVolume: 0,\n    videoLoop: true,\n    videoPlayOnlyVisible: true,\n    videoLazyLoading: true,\n    disableVideo: false,\n    // Video callbacks.\n    onVideoInsert: null,\n    onVideoWorkerInit: null\n};\n/* eslint-disable import/no-mutable-exports */ /* eslint-disable no-restricted-globals */ let $4f4d636ec052f8d7$var$win$1;\nif (typeof window !== \"undefined\") $4f4d636ec052f8d7$var$win$1 = window;\nelse if (typeof $parcel$global !== \"undefined\") $4f4d636ec052f8d7$var$win$1 = $parcel$global;\nelse if (typeof self !== \"undefined\") $4f4d636ec052f8d7$var$win$1 = self;\nelse $4f4d636ec052f8d7$var$win$1 = {};\nvar $4f4d636ec052f8d7$var$global$2 = $4f4d636ec052f8d7$var$win$1;\n/**\n * Add styles to element.\n *\n * @param {Element} el - element.\n * @param {String|Object} styles - styles list.\n *\n * @returns {Element}\n */ function $4f4d636ec052f8d7$var$css(el, styles) {\n    if (typeof styles === \"string\") return $4f4d636ec052f8d7$var$global$2.getComputedStyle(el).getPropertyValue(styles);\n    Object.keys(styles).forEach((key)=>{\n        el.style[key] = styles[key];\n    });\n    return el;\n}\n/**\n * Extend like jQuery.extend\n *\n * @param {Object} out - output object.\n * @param {...any} args - additional objects to extend.\n *\n * @returns {Object}\n */ function $4f4d636ec052f8d7$var$extend$1(out, ...args) {\n    out = out || {};\n    Object.keys(args).forEach((i)=>{\n        if (!args[i]) return;\n        Object.keys(args[i]).forEach((key)=>{\n            out[key] = args[i][key];\n        });\n    });\n    return out;\n}\n/**\n * Get all parents of the element.\n *\n * @param {Element} elem - DOM element.\n *\n * @returns {Array}\n */ function $4f4d636ec052f8d7$var$getParents(elem) {\n    const parents = [];\n    while(elem.parentElement !== null){\n        elem = elem.parentElement;\n        if (elem.nodeType === 1) parents.push(elem);\n    }\n    return parents;\n}\n/**\n * Document ready callback.\n * @param {Function} callback - callback will be fired once Document ready.\n */ function $4f4d636ec052f8d7$var$ready(callback) {\n    if (document.readyState === \"complete\" || document.readyState === \"interactive\") // Already ready or interactive, execute callback\n    callback();\n    else document.addEventListener(\"DOMContentLoaded\", callback, {\n        capture: true,\n        once: true,\n        passive: true\n    });\n}\nconst { navigator: $4f4d636ec052f8d7$var$navigator$1 } = $4f4d636ec052f8d7$var$global$2;\nconst $4f4d636ec052f8d7$var$mobileAgent = /*#__PURE__*/ /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test($4f4d636ec052f8d7$var$navigator$1.userAgent);\nfunction $4f4d636ec052f8d7$var$isMobile() {\n    return $4f4d636ec052f8d7$var$mobileAgent;\n}\nlet $4f4d636ec052f8d7$var$wndW;\nlet $4f4d636ec052f8d7$var$wndH;\nlet $4f4d636ec052f8d7$var$$deviceHelper;\n/**\n * The most popular mobile browsers changes height after page scroll and this generates image jumping.\n * We can fix it using this workaround with vh units.\n */ function $4f4d636ec052f8d7$var$getDeviceHeight() {\n    if (!$4f4d636ec052f8d7$var$$deviceHelper && document.body) {\n        $4f4d636ec052f8d7$var$$deviceHelper = document.createElement(\"div\");\n        $4f4d636ec052f8d7$var$$deviceHelper.style.cssText = \"position: fixed; top: -9999px; left: 0; height: 100vh; width: 0;\";\n        document.body.appendChild($4f4d636ec052f8d7$var$$deviceHelper);\n    }\n    return ($4f4d636ec052f8d7$var$$deviceHelper ? $4f4d636ec052f8d7$var$$deviceHelper.clientHeight : 0) || $4f4d636ec052f8d7$var$global$2.innerHeight || document.documentElement.clientHeight;\n}\nfunction $4f4d636ec052f8d7$var$updateWindowHeight() {\n    $4f4d636ec052f8d7$var$wndW = $4f4d636ec052f8d7$var$global$2.innerWidth || document.documentElement.clientWidth;\n    if ($4f4d636ec052f8d7$var$isMobile()) $4f4d636ec052f8d7$var$wndH = $4f4d636ec052f8d7$var$getDeviceHeight();\n    else $4f4d636ec052f8d7$var$wndH = $4f4d636ec052f8d7$var$global$2.innerHeight || document.documentElement.clientHeight;\n}\n$4f4d636ec052f8d7$var$updateWindowHeight();\n$4f4d636ec052f8d7$var$global$2.addEventListener(\"resize\", $4f4d636ec052f8d7$var$updateWindowHeight);\n$4f4d636ec052f8d7$var$global$2.addEventListener(\"orientationchange\", $4f4d636ec052f8d7$var$updateWindowHeight);\n$4f4d636ec052f8d7$var$global$2.addEventListener(\"load\", $4f4d636ec052f8d7$var$updateWindowHeight);\n$4f4d636ec052f8d7$var$ready(()=>{\n    $4f4d636ec052f8d7$var$updateWindowHeight();\n});\nfunction $4f4d636ec052f8d7$var$getWindowSize() {\n    return {\n        width: $4f4d636ec052f8d7$var$wndW,\n        height: $4f4d636ec052f8d7$var$wndH\n    };\n}\n// List with all jarallax instances\n// need to render all in one scroll/resize event.\nconst $4f4d636ec052f8d7$var$jarallaxList = [];\nfunction $4f4d636ec052f8d7$var$updateParallax() {\n    if (!$4f4d636ec052f8d7$var$jarallaxList.length) return;\n    const { width: wndW, height: wndH } = $4f4d636ec052f8d7$var$getWindowSize();\n    $4f4d636ec052f8d7$var$jarallaxList.forEach((data, k)=>{\n        const { instance: instance, oldData: oldData } = data;\n        if (!instance.isVisible()) return;\n        const clientRect = instance.$item.getBoundingClientRect();\n        const newData = {\n            width: clientRect.width,\n            height: clientRect.height,\n            top: clientRect.top,\n            bottom: clientRect.bottom,\n            wndW: wndW,\n            wndH: wndH\n        };\n        const isResized = !oldData || oldData.wndW !== newData.wndW || oldData.wndH !== newData.wndH || oldData.width !== newData.width || oldData.height !== newData.height;\n        const isScrolled = isResized || !oldData || oldData.top !== newData.top || oldData.bottom !== newData.bottom;\n        $4f4d636ec052f8d7$var$jarallaxList[k].oldData = newData;\n        if (isResized) instance.onResize();\n        if (isScrolled) instance.onScroll();\n    });\n    $4f4d636ec052f8d7$var$global$2.requestAnimationFrame($4f4d636ec052f8d7$var$updateParallax);\n}\nconst $4f4d636ec052f8d7$var$visibilityObserver = /*#__PURE__*/ new $4f4d636ec052f8d7$var$global$2.IntersectionObserver((entries)=>{\n    entries.forEach((entry)=>{\n        entry.target.jarallax.isElementInViewport = entry.isIntersecting;\n    });\n}, {\n    // We have to start parallax calculation before the block is in view\n    // to prevent possible parallax jumping.\n    rootMargin: \"50px\"\n});\nfunction $4f4d636ec052f8d7$var$addObserver(instance) {\n    $4f4d636ec052f8d7$var$jarallaxList.push({\n        instance: instance\n    });\n    if ($4f4d636ec052f8d7$var$jarallaxList.length === 1) $4f4d636ec052f8d7$var$global$2.requestAnimationFrame($4f4d636ec052f8d7$var$updateParallax);\n    $4f4d636ec052f8d7$var$visibilityObserver.observe(instance.options.elementInViewport || instance.$item);\n}\nfunction $4f4d636ec052f8d7$var$removeObserver(instance) {\n    $4f4d636ec052f8d7$var$jarallaxList.forEach((data, key)=>{\n        if (data.instance.instanceID === instance.instanceID) $4f4d636ec052f8d7$var$jarallaxList.splice(key, 1);\n    });\n    $4f4d636ec052f8d7$var$visibilityObserver.unobserve(instance.options.elementInViewport || instance.$item);\n}\n/* eslint-disable class-methods-use-this */ const { navigator: $4f4d636ec052f8d7$var$navigator } = $4f4d636ec052f8d7$var$global$2;\nlet $4f4d636ec052f8d7$var$instanceID = 0;\n// Jarallax class\nclass $4f4d636ec052f8d7$var$Jarallax {\n    constructor(item, userOptions){\n        const self1 = this;\n        self1.instanceID = $4f4d636ec052f8d7$var$instanceID;\n        $4f4d636ec052f8d7$var$instanceID += 1;\n        self1.$item = item;\n        self1.defaults = {\n            ...$4f4d636ec052f8d7$var$defaults$1\n        };\n        // prepare data-options\n        const dataOptions = self1.$item.dataset || {};\n        const pureDataOptions = {};\n        Object.keys(dataOptions).forEach((key)=>{\n            const lowerCaseOption = key.substr(0, 1).toLowerCase() + key.substr(1);\n            if (lowerCaseOption && typeof self1.defaults[lowerCaseOption] !== \"undefined\") pureDataOptions[lowerCaseOption] = dataOptions[key];\n        });\n        self1.options = self1.extend({}, self1.defaults, pureDataOptions, userOptions);\n        self1.pureOptions = self1.extend({}, self1.options);\n        // prepare 'true' and 'false' strings to boolean\n        Object.keys(self1.options).forEach((key)=>{\n            if (self1.options[key] === \"true\") self1.options[key] = true;\n            else if (self1.options[key] === \"false\") self1.options[key] = false;\n        });\n        // fix speed option [-1.0, 2.0]\n        self1.options.speed = Math.min(2, Math.max(-1, parseFloat(self1.options.speed)));\n        // prepare disableParallax callback\n        if (typeof self1.options.disableParallax === \"string\") self1.options.disableParallax = new RegExp(self1.options.disableParallax);\n        if (self1.options.disableParallax instanceof RegExp) {\n            const disableParallaxRegexp = self1.options.disableParallax;\n            self1.options.disableParallax = ()=>disableParallaxRegexp.test($4f4d636ec052f8d7$var$navigator.userAgent);\n        }\n        if (typeof self1.options.disableParallax !== \"function\") self1.options.disableParallax = ()=>false;\n        // prepare disableVideo callback\n        if (typeof self1.options.disableVideo === \"string\") self1.options.disableVideo = new RegExp(self1.options.disableVideo);\n        if (self1.options.disableVideo instanceof RegExp) {\n            const disableVideoRegexp = self1.options.disableVideo;\n            self1.options.disableVideo = ()=>disableVideoRegexp.test($4f4d636ec052f8d7$var$navigator.userAgent);\n        }\n        if (typeof self1.options.disableVideo !== \"function\") self1.options.disableVideo = ()=>false;\n        // custom element to check if parallax in viewport\n        let elementInVP = self1.options.elementInViewport;\n        // get first item from array\n        if (elementInVP && typeof elementInVP === \"object\" && typeof elementInVP.length !== \"undefined\") [elementInVP] = elementInVP;\n        // check if dom element\n        if (!(elementInVP instanceof Element)) elementInVP = null;\n        self1.options.elementInViewport = elementInVP;\n        self1.image = {\n            src: self1.options.imgSrc || null,\n            $container: null,\n            useImgTag: false,\n            // 1. Position fixed is needed for the most of browsers because absolute position have glitches\n            // 2. On MacOS with smooth scroll there is a huge lags with absolute position - https://github.com/nk-o/jarallax/issues/75\n            // 3. Previously used 'absolute' for mobile devices. But we re-tested on iPhone 12 and 'fixed' position is working better, then 'absolute', so for now position is always 'fixed'\n            position: \"fixed\"\n        };\n        if (self1.initImg() && self1.canInitParallax()) self1.init();\n    }\n    css(el, styles) {\n        return $4f4d636ec052f8d7$var$css(el, styles);\n    }\n    extend(out, ...args) {\n        return $4f4d636ec052f8d7$var$extend$1(out, ...args);\n    }\n    // get window size and scroll position. Useful for extensions\n    getWindowData() {\n        const { width: width, height: height } = $4f4d636ec052f8d7$var$getWindowSize();\n        return {\n            width: width,\n            height: height,\n            y: document.documentElement.scrollTop\n        };\n    }\n    // Jarallax functions\n    initImg() {\n        const self1 = this;\n        // find image element\n        let $imgElement = self1.options.imgElement;\n        if ($imgElement && typeof $imgElement === \"string\") $imgElement = self1.$item.querySelector($imgElement);\n        // check if dom element\n        if (!($imgElement instanceof Element)) {\n            if (self1.options.imgSrc) {\n                $imgElement = new Image();\n                $imgElement.src = self1.options.imgSrc;\n            } else $imgElement = null;\n        }\n        if ($imgElement) {\n            if (self1.options.keepImg) self1.image.$item = $imgElement.cloneNode(true);\n            else {\n                self1.image.$item = $imgElement;\n                self1.image.$itemParent = $imgElement.parentNode;\n            }\n            self1.image.useImgTag = true;\n        }\n        // true if there is img tag\n        if (self1.image.$item) return true;\n        // get image src\n        if (self1.image.src === null) {\n            self1.image.src = \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\";\n            self1.image.bgImage = self1.css(self1.$item, \"background-image\");\n        }\n        return !(!self1.image.bgImage || self1.image.bgImage === \"none\");\n    }\n    canInitParallax() {\n        return !this.options.disableParallax();\n    }\n    init() {\n        const self1 = this;\n        const containerStyles = {\n            position: \"absolute\",\n            top: 0,\n            left: 0,\n            width: \"100%\",\n            height: \"100%\",\n            overflow: \"hidden\"\n        };\n        let imageStyles = {\n            pointerEvents: \"none\",\n            transformStyle: \"preserve-3d\",\n            backfaceVisibility: \"hidden\"\n        };\n        if (!self1.options.keepImg) {\n            // save default user styles\n            const curStyle = self1.$item.getAttribute(\"style\");\n            if (curStyle) self1.$item.setAttribute(\"data-jarallax-original-styles\", curStyle);\n            if (self1.image.useImgTag) {\n                const curImgStyle = self1.image.$item.getAttribute(\"style\");\n                if (curImgStyle) self1.image.$item.setAttribute(\"data-jarallax-original-styles\", curImgStyle);\n            }\n        }\n        // set relative position and z-index to the parent\n        if (self1.css(self1.$item, \"position\") === \"static\") self1.css(self1.$item, {\n            position: \"relative\"\n        });\n        if (self1.css(self1.$item, \"z-index\") === \"auto\") self1.css(self1.$item, {\n            zIndex: 0\n        });\n        // container for parallax image\n        self1.image.$container = document.createElement(\"div\");\n        self1.css(self1.image.$container, containerStyles);\n        self1.css(self1.image.$container, {\n            \"z-index\": self1.options.zIndex\n        });\n        // it will remove some image overlapping\n        // overlapping occur due to an image position fixed inside absolute position element\n        // needed only when background in fixed position\n        if (this.image.position === \"fixed\") self1.css(self1.image.$container, {\n            \"-webkit-clip-path\": \"polygon(0 0, 100% 0, 100% 100%, 0 100%)\",\n            \"clip-path\": \"polygon(0 0, 100% 0, 100% 100%, 0 100%)\"\n        });\n        // Add container unique ID.\n        self1.image.$container.setAttribute(\"id\", `jarallax-container-${self1.instanceID}`);\n        // Add container class.\n        if (self1.options.containerClass) self1.image.$container.setAttribute(\"class\", self1.options.containerClass);\n        self1.$item.appendChild(self1.image.$container);\n        // use img tag\n        if (self1.image.useImgTag) imageStyles = self1.extend({\n            \"object-fit\": self1.options.imgSize,\n            \"object-position\": self1.options.imgPosition,\n            \"max-width\": \"none\"\n        }, containerStyles, imageStyles);\n        else {\n            self1.image.$item = document.createElement(\"div\");\n            if (self1.image.src) imageStyles = self1.extend({\n                \"background-position\": self1.options.imgPosition,\n                \"background-size\": self1.options.imgSize,\n                \"background-repeat\": self1.options.imgRepeat,\n                \"background-image\": self1.image.bgImage || `url(\"${self1.image.src}\")`\n            }, containerStyles, imageStyles);\n        }\n        if (self1.options.type === \"opacity\" || self1.options.type === \"scale\" || self1.options.type === \"scale-opacity\" || self1.options.speed === 1) self1.image.position = \"absolute\";\n        // 1. Check if one of parents have transform style (without this check, scroll transform will be inverted if used parallax with position fixed)\n        //    discussion - https://github.com/nk-o/jarallax/issues/9\n        // 2. Check if parents have overflow scroll\n        if (self1.image.position === \"fixed\") {\n            const $parents = $4f4d636ec052f8d7$var$getParents(self1.$item).filter((el)=>{\n                const styles = $4f4d636ec052f8d7$var$global$2.getComputedStyle(el);\n                const parentTransform = styles[\"-webkit-transform\"] || styles[\"-moz-transform\"] || styles.transform;\n                const overflowRegex = /(auto|scroll)/;\n                return parentTransform && parentTransform !== \"none\" || overflowRegex.test(styles.overflow + styles[\"overflow-y\"] + styles[\"overflow-x\"]);\n            });\n            self1.image.position = $parents.length ? \"absolute\" : \"fixed\";\n        }\n        // add position to parallax block\n        imageStyles.position = self1.image.position;\n        // insert parallax image\n        self1.css(self1.image.$item, imageStyles);\n        self1.image.$container.appendChild(self1.image.$item);\n        // set initial position and size\n        self1.onResize();\n        self1.onScroll(true);\n        // call onInit event\n        if (self1.options.onInit) self1.options.onInit.call(self1);\n        // remove default user background\n        if (self1.css(self1.$item, \"background-image\") !== \"none\") self1.css(self1.$item, {\n            \"background-image\": \"none\"\n        });\n        $4f4d636ec052f8d7$var$addObserver(self1);\n    }\n    destroy() {\n        const self1 = this;\n        $4f4d636ec052f8d7$var$removeObserver(self1);\n        // return styles on container as before jarallax init\n        const originalStylesTag = self1.$item.getAttribute(\"data-jarallax-original-styles\");\n        self1.$item.removeAttribute(\"data-jarallax-original-styles\");\n        // null occurs if there is no style tag before jarallax init\n        if (!originalStylesTag) self1.$item.removeAttribute(\"style\");\n        else self1.$item.setAttribute(\"style\", originalStylesTag);\n        if (self1.image.useImgTag) {\n            // return styles on img tag as before jarallax init\n            const originalStylesImgTag = self1.image.$item.getAttribute(\"data-jarallax-original-styles\");\n            self1.image.$item.removeAttribute(\"data-jarallax-original-styles\");\n            // null occurs if there is no style tag before jarallax init\n            if (!originalStylesImgTag) self1.image.$item.removeAttribute(\"style\");\n            else self1.image.$item.setAttribute(\"style\", originalStylesTag);\n            // move img tag to its default position\n            if (self1.image.$itemParent) self1.image.$itemParent.appendChild(self1.image.$item);\n        }\n        // remove additional dom elements\n        if (self1.image.$container) self1.image.$container.parentNode.removeChild(self1.image.$container);\n        // call onDestroy event\n        if (self1.options.onDestroy) self1.options.onDestroy.call(self1);\n        // delete jarallax from item\n        delete self1.$item.jarallax;\n    }\n    coverImage() {\n        const self1 = this;\n        const { height: wndH } = $4f4d636ec052f8d7$var$getWindowSize();\n        const rect = self1.image.$container.getBoundingClientRect();\n        const contH = rect.height;\n        const { speed: speed } = self1.options;\n        const isScroll = self1.options.type === \"scroll\" || self1.options.type === \"scroll-opacity\";\n        let scrollDist = 0;\n        let resultH = contH;\n        let resultMT = 0;\n        // scroll parallax\n        if (isScroll) {\n            // scroll distance and height for image\n            if (speed < 0) {\n                scrollDist = speed * Math.max(contH, wndH);\n                if (wndH < contH) scrollDist -= speed * (contH - wndH);\n            } else scrollDist = speed * (contH + wndH);\n            // size for scroll parallax\n            if (speed > 1) resultH = Math.abs(scrollDist - wndH);\n            else if (speed < 0) resultH = scrollDist / speed + Math.abs(scrollDist);\n            else resultH += (wndH - contH) * (1 - speed);\n            scrollDist /= 2;\n        }\n        // store scroll distance\n        self1.parallaxScrollDistance = scrollDist;\n        // vertical center\n        if (isScroll) resultMT = (wndH - resultH) / 2;\n        else resultMT = (contH - resultH) / 2;\n        // apply result to item\n        self1.css(self1.image.$item, {\n            height: `${resultH}px`,\n            marginTop: `${resultMT}px`,\n            left: self1.image.position === \"fixed\" ? `${rect.left}px` : \"0\",\n            width: `${rect.width}px`\n        });\n        // call onCoverImage event\n        if (self1.options.onCoverImage) self1.options.onCoverImage.call(self1);\n        // return some useful data. Used in the video cover function\n        return {\n            image: {\n                height: resultH,\n                marginTop: resultMT\n            },\n            container: rect\n        };\n    }\n    isVisible() {\n        return this.isElementInViewport || false;\n    }\n    onScroll(force) {\n        const self1 = this;\n        // stop calculations if item is not in viewport\n        if (!force && !self1.isVisible()) return;\n        const { height: wndH } = $4f4d636ec052f8d7$var$getWindowSize();\n        const rect = self1.$item.getBoundingClientRect();\n        const contT = rect.top;\n        const contH = rect.height;\n        const styles = {};\n        // calculate parallax helping variables\n        const beforeTop = Math.max(0, contT);\n        const beforeTopEnd = Math.max(0, contH + contT);\n        const afterTop = Math.max(0, -contT);\n        const beforeBottom = Math.max(0, contT + contH - wndH);\n        const beforeBottomEnd = Math.max(0, contH - (contT + contH - wndH));\n        const afterBottom = Math.max(0, -contT + wndH - contH);\n        const fromViewportCenter = 1 - 2 * ((wndH - contT) / (wndH + contH));\n        // calculate on how percent of section is visible\n        let visiblePercent = 1;\n        if (contH < wndH) visiblePercent = 1 - (afterTop || beforeBottom) / contH;\n        else if (beforeTopEnd <= wndH) visiblePercent = beforeTopEnd / wndH;\n        else if (beforeBottomEnd <= wndH) visiblePercent = beforeBottomEnd / wndH;\n        // opacity\n        if (self1.options.type === \"opacity\" || self1.options.type === \"scale-opacity\" || self1.options.type === \"scroll-opacity\") {\n            styles.transform = \"translate3d(0,0,0)\";\n            styles.opacity = visiblePercent;\n        }\n        // scale\n        if (self1.options.type === \"scale\" || self1.options.type === \"scale-opacity\") {\n            let scale = 1;\n            if (self1.options.speed < 0) scale -= self1.options.speed * visiblePercent;\n            else scale += self1.options.speed * (1 - visiblePercent);\n            styles.transform = `scale(${scale}) translate3d(0,0,0)`;\n        }\n        // scroll\n        if (self1.options.type === \"scroll\" || self1.options.type === \"scroll-opacity\") {\n            let positionY = self1.parallaxScrollDistance * fromViewportCenter;\n            // fix if parallax block in absolute position\n            if (self1.image.position === \"absolute\") positionY -= contT;\n            styles.transform = `translate3d(0,${positionY}px,0)`;\n        }\n        self1.css(self1.image.$item, styles);\n        // call onScroll event\n        if (self1.options.onScroll) self1.options.onScroll.call(self1, {\n            section: rect,\n            beforeTop: beforeTop,\n            beforeTopEnd: beforeTopEnd,\n            afterTop: afterTop,\n            beforeBottom: beforeBottom,\n            beforeBottomEnd: beforeBottomEnd,\n            afterBottom: afterBottom,\n            visiblePercent: visiblePercent,\n            fromViewportCenter: fromViewportCenter\n        });\n    }\n    onResize() {\n        this.coverImage();\n    }\n}\n// global definition\nconst $4f4d636ec052f8d7$var$jarallax$1 = function(items, options, ...args) {\n    // check for dom element\n    // thanks: http://stackoverflow.com/questions/384286/javascript-isdom-how-do-you-check-if-a-javascript-object-is-a-dom-object\n    if (typeof HTMLElement === \"object\" ? items instanceof HTMLElement : items && typeof items === \"object\" && items !== null && items.nodeType === 1 && typeof items.nodeName === \"string\") items = [\n        items\n    ];\n    const len = items.length;\n    let k = 0;\n    let ret;\n    for(k; k < len; k += 1){\n        if (typeof options === \"object\" || typeof options === \"undefined\") {\n            if (!items[k].jarallax) items[k].jarallax = new $4f4d636ec052f8d7$var$Jarallax(items[k], options);\n        } else if (items[k].jarallax) // eslint-disable-next-line prefer-spread\n        ret = items[k].jarallax[options].apply(items[k].jarallax, args);\n        if (typeof ret !== \"undefined\") return ret;\n    }\n    return items;\n};\n$4f4d636ec052f8d7$var$jarallax$1.constructor = $4f4d636ec052f8d7$var$Jarallax;\n/*!\n * Video Worker v2.1.5 (https://github.com/nk-o/video-worker)\n * Copyright 2022 nK <https://nkdev.info>\n * Licensed under MIT (https://github.com/nk-o/video-worker/blob/master/LICENSE)\n */ /* eslint-disable import/no-mutable-exports */ /* eslint-disable no-restricted-globals */ let $4f4d636ec052f8d7$var$win;\nif (typeof window !== \"undefined\") $4f4d636ec052f8d7$var$win = window;\nelse if (typeof $parcel$global !== \"undefined\") $4f4d636ec052f8d7$var$win = $parcel$global;\nelse if (typeof self !== \"undefined\") $4f4d636ec052f8d7$var$win = self;\nelse $4f4d636ec052f8d7$var$win = {};\nvar $4f4d636ec052f8d7$var$global$1 = $4f4d636ec052f8d7$var$win;\n// Deferred\n// thanks http://stackoverflow.com/questions/18096715/implement-deferred-object-without-using-jquery\nfunction $4f4d636ec052f8d7$var$Deferred() {\n    this.doneCallbacks = [];\n    this.failCallbacks = [];\n}\n$4f4d636ec052f8d7$var$Deferred.prototype = {\n    execute (list, args) {\n        let i = list.length;\n        // eslint-disable-next-line no-param-reassign\n        args = Array.prototype.slice.call(args);\n        while(i){\n            i -= 1;\n            list[i].apply(null, args);\n        }\n    },\n    resolve (...args) {\n        this.execute(this.doneCallbacks, args);\n    },\n    reject (...args) {\n        this.execute(this.failCallbacks, args);\n    },\n    done (callback) {\n        this.doneCallbacks.push(callback);\n    },\n    fail (callback) {\n        this.failCallbacks.push(callback);\n    }\n};\nvar $4f4d636ec052f8d7$var$defaults = {\n    autoplay: false,\n    loop: false,\n    mute: false,\n    volume: 100,\n    showControls: true,\n    accessibilityHidden: false,\n    // start / end video time in seconds\n    startTime: 0,\n    endTime: 0\n};\n/**\n * Extend like jQuery.extend\n *\n * @param {Object} out - output object.\n * @param {...any} args - additional objects to extend.\n *\n * @returns {Object}\n */ function $4f4d636ec052f8d7$var$extend(out, ...args) {\n    out = out || {};\n    Object.keys(args).forEach((i)=>{\n        if (!args[i]) return;\n        Object.keys(args[i]).forEach((key)=>{\n            out[key] = args[i][key];\n        });\n    });\n    return out;\n}\nlet $4f4d636ec052f8d7$var$ID = 0;\nlet $4f4d636ec052f8d7$var$YoutubeAPIadded = 0;\nlet $4f4d636ec052f8d7$var$VimeoAPIadded = 0;\nlet $4f4d636ec052f8d7$var$loadingYoutubePlayer = 0;\nlet $4f4d636ec052f8d7$var$loadingVimeoPlayer = 0;\nconst $4f4d636ec052f8d7$var$loadingYoutubeDefer = /*#__PURE__*/ new $4f4d636ec052f8d7$var$Deferred();\nconst $4f4d636ec052f8d7$var$loadingVimeoDefer = /*#__PURE__*/ new $4f4d636ec052f8d7$var$Deferred();\nclass $4f4d636ec052f8d7$var$VideoWorker {\n    constructor(url, options){\n        const self1 = this;\n        self1.url = url;\n        self1.options_default = {\n            ...$4f4d636ec052f8d7$var$defaults\n        };\n        self1.options = $4f4d636ec052f8d7$var$extend({}, self1.options_default, options);\n        // check URL\n        self1.videoID = self1.parseURL(url);\n        // init\n        if (self1.videoID) {\n            self1.ID = $4f4d636ec052f8d7$var$ID;\n            $4f4d636ec052f8d7$var$ID += 1;\n            self1.loadAPI();\n            self1.init();\n        }\n    }\n    parseURL(url) {\n        // parse youtube ID\n        function getYoutubeID(ytUrl) {\n            // eslint-disable-next-line no-useless-escape\n            const regExp = /.*(?:youtu.be\\/|v\\/|u\\/\\w\\/|embed\\/|shorts\\/|watch\\?v=)([^#\\&\\?]*).*/;\n            const match = ytUrl.match(regExp);\n            return match && match[1].length === 11 ? match[1] : false;\n        }\n        // parse vimeo ID\n        function getVimeoID(vmUrl) {\n            // eslint-disable-next-line no-useless-escape\n            const regExp = /https?:\\/\\/(?:www\\.|player\\.)?vimeo.com\\/(?:channels\\/(?:\\w+\\/)?|groups\\/([^/]*)\\/videos\\/|album\\/(\\d+)\\/video\\/|video\\/|)(\\d+)(?:$|\\/|\\?)/;\n            const match = vmUrl.match(regExp);\n            return match && match[3] ? match[3] : false;\n        }\n        // parse local string\n        function getLocalVideos(locUrl) {\n            // eslint-disable-next-line no-useless-escape\n            const videoFormats = locUrl.split(/,(?=mp4\\:|webm\\:|ogv\\:|ogg\\:)/);\n            const result = {};\n            let ready = 0;\n            videoFormats.forEach((val)=>{\n                // eslint-disable-next-line no-useless-escape\n                const match = val.match(/^(mp4|webm|ogv|ogg)\\:(.*)/);\n                if (match && match[1] && match[2]) {\n                    // eslint-disable-next-line prefer-destructuring\n                    result[match[1] === \"ogv\" ? \"ogg\" : match[1]] = match[2];\n                    ready = 1;\n                }\n            });\n            return ready ? result : false;\n        }\n        const Youtube = getYoutubeID(url);\n        const Vimeo = getVimeoID(url);\n        const Local = getLocalVideos(url);\n        if (Youtube) {\n            this.type = \"youtube\";\n            return Youtube;\n        }\n        if (Vimeo) {\n            this.type = \"vimeo\";\n            return Vimeo;\n        }\n        if (Local) {\n            this.type = \"local\";\n            return Local;\n        }\n        return false;\n    }\n    isValid() {\n        return !!this.videoID;\n    }\n    // events\n    on(name, callback) {\n        this.userEventsList = this.userEventsList || [];\n        // add new callback in events list\n        (this.userEventsList[name] || (this.userEventsList[name] = [])).push(callback);\n    }\n    off(name, callback) {\n        if (!this.userEventsList || !this.userEventsList[name]) return;\n        if (!callback) delete this.userEventsList[name];\n        else this.userEventsList[name].forEach((val, key)=>{\n            if (val === callback) this.userEventsList[name][key] = false;\n        });\n    }\n    fire(name, ...args) {\n        if (this.userEventsList && typeof this.userEventsList[name] !== \"undefined\") this.userEventsList[name].forEach((val)=>{\n            // call with all arguments\n            if (val) val.apply(this, args);\n        });\n    }\n    play(start) {\n        const self1 = this;\n        if (!self1.player) return;\n        if (self1.type === \"youtube\" && self1.player.playVideo) {\n            if (typeof start !== \"undefined\") self1.player.seekTo(start || 0);\n            if ($4f4d636ec052f8d7$var$global$1.YT.PlayerState.PLAYING !== self1.player.getPlayerState()) self1.player.playVideo();\n        }\n        if (self1.type === \"vimeo\") {\n            if (typeof start !== \"undefined\") self1.player.setCurrentTime(start);\n            self1.player.getPaused().then((paused)=>{\n                if (paused) self1.player.play();\n            });\n        }\n        if (self1.type === \"local\") {\n            if (typeof start !== \"undefined\") self1.player.currentTime = start;\n            if (self1.player.paused) self1.player.play();\n        }\n    }\n    pause() {\n        const self1 = this;\n        if (!self1.player) return;\n        if (self1.type === \"youtube\" && self1.player.pauseVideo) {\n            if ($4f4d636ec052f8d7$var$global$1.YT.PlayerState.PLAYING === self1.player.getPlayerState()) self1.player.pauseVideo();\n        }\n        if (self1.type === \"vimeo\") self1.player.getPaused().then((paused)=>{\n            if (!paused) self1.player.pause();\n        });\n        if (self1.type === \"local\") {\n            if (!self1.player.paused) self1.player.pause();\n        }\n    }\n    mute() {\n        const self1 = this;\n        if (!self1.player) return;\n        if (self1.type === \"youtube\" && self1.player.mute) self1.player.mute();\n        if (self1.type === \"vimeo\" && self1.player.setVolume) self1.setVolume(0);\n        if (self1.type === \"local\") self1.$video.muted = true;\n    }\n    unmute() {\n        const self1 = this;\n        if (!self1.player) return;\n        if (self1.type === \"youtube\" && self1.player.mute) self1.player.unMute();\n        if (self1.type === \"vimeo\" && self1.player.setVolume) // In case the default volume is 0, we have to set 100 when unmute.\n        self1.setVolume(self1.options.volume || 100);\n        if (self1.type === \"local\") self1.$video.muted = false;\n    }\n    setVolume(volume = false) {\n        const self1 = this;\n        if (!self1.player || typeof volume !== \"number\") return;\n        if (self1.type === \"youtube\" && self1.player.setVolume) self1.player.setVolume(volume);\n        if (self1.type === \"vimeo\" && self1.player.setVolume) self1.player.setVolume(volume / 100);\n        if (self1.type === \"local\") self1.$video.volume = volume / 100;\n    }\n    getVolume(callback) {\n        const self1 = this;\n        if (!self1.player) {\n            callback(false);\n            return;\n        }\n        if (self1.type === \"youtube\" && self1.player.getVolume) callback(self1.player.getVolume());\n        if (self1.type === \"vimeo\" && self1.player.getVolume) self1.player.getVolume().then((volume)=>{\n            callback(volume * 100);\n        });\n        if (self1.type === \"local\") callback(self1.$video.volume * 100);\n    }\n    getMuted(callback) {\n        const self1 = this;\n        if (!self1.player) {\n            callback(null);\n            return;\n        }\n        if (self1.type === \"youtube\" && self1.player.isMuted) callback(self1.player.isMuted());\n        if (self1.type === \"vimeo\" && self1.player.getVolume) self1.player.getVolume().then((volume)=>{\n            callback(!!volume);\n        });\n        if (self1.type === \"local\") callback(self1.$video.muted);\n    }\n    getImageURL(callback) {\n        const self1 = this;\n        if (self1.videoImage) {\n            callback(self1.videoImage);\n            return;\n        }\n        if (self1.type === \"youtube\") {\n            const availableSizes = [\n                \"maxresdefault\",\n                \"sddefault\",\n                \"hqdefault\",\n                \"0\"\n            ];\n            let step = 0;\n            const tempImg = new Image();\n            tempImg.onload = function() {\n                // if no thumbnail, youtube add their own image with width = 120px\n                if ((this.naturalWidth || this.width) !== 120 || step === availableSizes.length - 1) {\n                    // ok\n                    self1.videoImage = `https://img.youtube.com/vi/${self1.videoID}/${availableSizes[step]}.jpg`;\n                    callback(self1.videoImage);\n                } else {\n                    // try another size\n                    step += 1;\n                    this.src = `https://img.youtube.com/vi/${self1.videoID}/${availableSizes[step]}.jpg`;\n                }\n            };\n            tempImg.src = `https://img.youtube.com/vi/${self1.videoID}/${availableSizes[step]}.jpg`;\n        }\n        if (self1.type === \"vimeo\") {\n            // We should provide width to get HQ thumbnail URL.\n            let width = $4f4d636ec052f8d7$var$global$1.innerWidth || 1920;\n            if ($4f4d636ec052f8d7$var$global$1.devicePixelRatio) width *= $4f4d636ec052f8d7$var$global$1.devicePixelRatio;\n            width = Math.min(width, 1920);\n            let request = new XMLHttpRequest();\n            // https://vimeo.com/api/oembed.json?url=https://vimeo.com/235212527\n            request.open(\"GET\", `https://vimeo.com/api/oembed.json?url=${self1.url}&width=${width}`, true);\n            request.onreadystatechange = function() {\n                if (this.readyState === 4) {\n                    if (this.status >= 200 && this.status < 400) {\n                        // Success!\n                        const response = JSON.parse(this.responseText);\n                        if (response.thumbnail_url) {\n                            self1.videoImage = response.thumbnail_url;\n                            callback(self1.videoImage);\n                        }\n                    }\n                }\n            };\n            request.send();\n            request = null;\n        }\n    }\n    // fallback to the old version.\n    getIframe(callback) {\n        this.getVideo(callback);\n    }\n    getVideo(callback) {\n        const self1 = this;\n        // return generated video block\n        if (self1.$video) {\n            callback(self1.$video);\n            return;\n        }\n        // generate new video block\n        self1.onAPIready(()=>{\n            let hiddenDiv;\n            if (!self1.$video) {\n                hiddenDiv = document.createElement(\"div\");\n                hiddenDiv.style.display = \"none\";\n            }\n            // Youtube\n            if (self1.type === \"youtube\") {\n                self1.playerOptions = {\n                    // GDPR Compliance.\n                    host: \"https://www.youtube-nocookie.com\",\n                    videoId: self1.videoID,\n                    playerVars: {\n                        autohide: 1,\n                        rel: 0,\n                        autoplay: 0,\n                        // autoplay enable on mobile devices\n                        playsinline: 1\n                    }\n                };\n                // hide controls\n                if (!self1.options.showControls) {\n                    self1.playerOptions.playerVars.iv_load_policy = 3;\n                    self1.playerOptions.playerVars.modestbranding = 1;\n                    self1.playerOptions.playerVars.controls = 0;\n                    self1.playerOptions.playerVars.showinfo = 0;\n                    self1.playerOptions.playerVars.disablekb = 1;\n                }\n                // events\n                let ytStarted;\n                let ytProgressInterval;\n                self1.playerOptions.events = {\n                    onReady (e) {\n                        // mute\n                        if (self1.options.mute) e.target.mute();\n                        else if (typeof self1.options.volume === \"number\") e.target.setVolume(self1.options.volume);\n                        // autoplay\n                        if (self1.options.autoplay) self1.play(self1.options.startTime);\n                        self1.fire(\"ready\", e);\n                        // For seamless loops, set the endTime to 0.1 seconds less than the video's duration\n                        // https://github.com/nk-o/video-worker/issues/2\n                        if (self1.options.loop && !self1.options.endTime) {\n                            const secondsOffset = 0.1;\n                            self1.options.endTime = self1.player.getDuration() - secondsOffset;\n                        }\n                        // volumechange\n                        setInterval(()=>{\n                            self1.getVolume((volume)=>{\n                                if (self1.options.volume !== volume) {\n                                    self1.options.volume = volume;\n                                    self1.fire(\"volumechange\", e);\n                                }\n                            });\n                        }, 150);\n                    },\n                    onStateChange (e) {\n                        // loop\n                        if (self1.options.loop && e.data === $4f4d636ec052f8d7$var$global$1.YT.PlayerState.ENDED) self1.play(self1.options.startTime);\n                        if (!ytStarted && e.data === $4f4d636ec052f8d7$var$global$1.YT.PlayerState.PLAYING) {\n                            ytStarted = 1;\n                            self1.fire(\"started\", e);\n                        }\n                        if (e.data === $4f4d636ec052f8d7$var$global$1.YT.PlayerState.PLAYING) self1.fire(\"play\", e);\n                        if (e.data === $4f4d636ec052f8d7$var$global$1.YT.PlayerState.PAUSED) self1.fire(\"pause\", e);\n                        if (e.data === $4f4d636ec052f8d7$var$global$1.YT.PlayerState.ENDED) self1.fire(\"ended\", e);\n                        // progress check\n                        if (e.data === $4f4d636ec052f8d7$var$global$1.YT.PlayerState.PLAYING) ytProgressInterval = setInterval(()=>{\n                            self1.fire(\"timeupdate\", e);\n                            // check for end of video and play again or stop\n                            if (self1.options.endTime && self1.player.getCurrentTime() >= self1.options.endTime) {\n                                if (self1.options.loop) self1.play(self1.options.startTime);\n                                else self1.pause();\n                            }\n                        }, 150);\n                        else clearInterval(ytProgressInterval);\n                    },\n                    onError (e) {\n                        self1.fire(\"error\", e);\n                    }\n                };\n                const firstInit = !self1.$video;\n                if (firstInit) {\n                    const div = document.createElement(\"div\");\n                    div.setAttribute(\"id\", self1.playerID);\n                    hiddenDiv.appendChild(div);\n                    document.body.appendChild(hiddenDiv);\n                }\n                self1.player = self1.player || new $4f4d636ec052f8d7$var$global$1.YT.Player(self1.playerID, self1.playerOptions);\n                if (firstInit) {\n                    self1.$video = document.getElementById(self1.playerID);\n                    // add accessibility attributes\n                    if (self1.options.accessibilityHidden) {\n                        self1.$video.setAttribute(\"tabindex\", \"-1\");\n                        self1.$video.setAttribute(\"aria-hidden\", \"true\");\n                    }\n                    // get video width and height\n                    self1.videoWidth = parseInt(self1.$video.getAttribute(\"width\"), 10) || 1280;\n                    self1.videoHeight = parseInt(self1.$video.getAttribute(\"height\"), 10) || 720;\n                }\n            }\n            // Vimeo\n            if (self1.type === \"vimeo\") {\n                self1.playerOptions = {\n                    // GDPR Compliance.\n                    dnt: 1,\n                    id: self1.videoID,\n                    autopause: 0,\n                    transparent: 0,\n                    autoplay: self1.options.autoplay ? 1 : 0,\n                    loop: self1.options.loop ? 1 : 0,\n                    muted: self1.options.mute || self1.options.volume === 0 ? 1 : 0\n                };\n                // hide controls\n                if (!self1.options.showControls) self1.playerOptions.controls = 0;\n                // enable background option\n                if (!self1.options.showControls && self1.options.loop && self1.options.autoplay) self1.playerOptions.background = 1;\n                if (!self1.$video) {\n                    let playerOptionsString = \"\";\n                    Object.keys(self1.playerOptions).forEach((key)=>{\n                        if (playerOptionsString !== \"\") playerOptionsString += \"&\";\n                        playerOptionsString += `${key}=${encodeURIComponent(self1.playerOptions[key])}`;\n                    });\n                    // we need to create iframe manually because when we create it using API\n                    // js events won't triggers after iframe moved to another place\n                    self1.$video = document.createElement(\"iframe\");\n                    self1.$video.setAttribute(\"id\", self1.playerID);\n                    self1.$video.setAttribute(\"src\", `https://player.vimeo.com/video/${self1.videoID}?${playerOptionsString}`);\n                    self1.$video.setAttribute(\"frameborder\", \"0\");\n                    self1.$video.setAttribute(\"mozallowfullscreen\", \"\");\n                    self1.$video.setAttribute(\"allowfullscreen\", \"\");\n                    self1.$video.setAttribute(\"title\", \"Vimeo video player\");\n                    // add accessibility attributes\n                    if (self1.options.accessibilityHidden) {\n                        self1.$video.setAttribute(\"tabindex\", \"-1\");\n                        self1.$video.setAttribute(\"aria-hidden\", \"true\");\n                    }\n                    hiddenDiv.appendChild(self1.$video);\n                    document.body.appendChild(hiddenDiv);\n                }\n                self1.player = self1.player || new $4f4d636ec052f8d7$var$global$1.Vimeo.Player(self1.$video, self1.playerOptions);\n                // Since Vimeo removed the `volume` parameter, we have to set it manually.\n                if (!self1.options.mute && typeof self1.options.volume === \"number\") self1.setVolume(self1.options.volume);\n                // set current time for autoplay\n                if (self1.options.startTime && self1.options.autoplay) self1.player.setCurrentTime(self1.options.startTime);\n                // get video width and height\n                self1.player.getVideoWidth().then((width)=>{\n                    self1.videoWidth = width || 1280;\n                });\n                self1.player.getVideoHeight().then((height)=>{\n                    self1.videoHeight = height || 720;\n                });\n                // events\n                let vmStarted;\n                self1.player.on(\"timeupdate\", (e)=>{\n                    if (!vmStarted) {\n                        self1.fire(\"started\", e);\n                        vmStarted = 1;\n                    }\n                    self1.fire(\"timeupdate\", e);\n                    // check for end of video and play again or stop\n                    if (self1.options.endTime) {\n                        if (self1.options.endTime && e.seconds >= self1.options.endTime) {\n                            if (self1.options.loop) self1.play(self1.options.startTime);\n                            else self1.pause();\n                        }\n                    }\n                });\n                self1.player.on(\"play\", (e)=>{\n                    self1.fire(\"play\", e);\n                    // check for the start time and start with it\n                    if (self1.options.startTime && e.seconds === 0) self1.play(self1.options.startTime);\n                });\n                self1.player.on(\"pause\", (e)=>{\n                    self1.fire(\"pause\", e);\n                });\n                self1.player.on(\"ended\", (e)=>{\n                    self1.fire(\"ended\", e);\n                });\n                self1.player.on(\"loaded\", (e)=>{\n                    self1.fire(\"ready\", e);\n                });\n                self1.player.on(\"volumechange\", (e)=>{\n                    self1.getVolume((volume)=>{\n                        self1.options.volume = volume;\n                    });\n                    self1.fire(\"volumechange\", e);\n                });\n                self1.player.on(\"error\", (e)=>{\n                    self1.fire(\"error\", e);\n                });\n            }\n            // Local\n            function addSourceToLocal(element, src, type) {\n                const source = document.createElement(\"source\");\n                source.src = src;\n                source.type = type;\n                element.appendChild(source);\n            }\n            if (self1.type === \"local\") {\n                if (!self1.$video) {\n                    self1.$video = document.createElement(\"video\");\n                    self1.player = self1.$video;\n                    // show controls\n                    if (self1.options.showControls) self1.$video.controls = true;\n                    // set volume\n                    if (typeof self1.options.volume === \"number\") self1.setVolume(self1.options.volume);\n                    // mute (it is required to mute after the volume set)\n                    if (self1.options.mute) self1.mute();\n                    // loop\n                    if (self1.options.loop) self1.$video.loop = true;\n                    // autoplay enable on mobile devices\n                    self1.$video.setAttribute(\"playsinline\", \"\");\n                    self1.$video.setAttribute(\"webkit-playsinline\", \"\");\n                    // add accessibility attributes\n                    if (self1.options.accessibilityHidden) {\n                        self1.$video.setAttribute(\"tabindex\", \"-1\");\n                        self1.$video.setAttribute(\"aria-hidden\", \"true\");\n                    }\n                    self1.$video.setAttribute(\"id\", self1.playerID);\n                    hiddenDiv.appendChild(self1.$video);\n                    document.body.appendChild(hiddenDiv);\n                    Object.keys(self1.videoID).forEach((key)=>{\n                        addSourceToLocal(self1.$video, self1.videoID[key], `video/${key}`);\n                    });\n                }\n                let locStarted;\n                self1.player.addEventListener(\"playing\", (e)=>{\n                    if (!locStarted) self1.fire(\"started\", e);\n                    locStarted = 1;\n                });\n                self1.player.addEventListener(\"timeupdate\", function(e) {\n                    self1.fire(\"timeupdate\", e);\n                    // check for end of video and play again or stop\n                    if (self1.options.endTime) {\n                        if (self1.options.endTime && this.currentTime >= self1.options.endTime) {\n                            if (self1.options.loop) self1.play(self1.options.startTime);\n                            else self1.pause();\n                        }\n                    }\n                });\n                self1.player.addEventListener(\"play\", (e)=>{\n                    self1.fire(\"play\", e);\n                });\n                self1.player.addEventListener(\"pause\", (e)=>{\n                    self1.fire(\"pause\", e);\n                });\n                self1.player.addEventListener(\"ended\", (e)=>{\n                    self1.fire(\"ended\", e);\n                });\n                self1.player.addEventListener(\"loadedmetadata\", function() {\n                    // get video width and height\n                    self1.videoWidth = this.videoWidth || 1280;\n                    self1.videoHeight = this.videoHeight || 720;\n                    self1.fire(\"ready\");\n                    // autoplay\n                    if (self1.options.autoplay) self1.play(self1.options.startTime);\n                });\n                self1.player.addEventListener(\"volumechange\", (e)=>{\n                    self1.getVolume((volume)=>{\n                        self1.options.volume = volume;\n                    });\n                    self1.fire(\"volumechange\", e);\n                });\n                self1.player.addEventListener(\"error\", (e)=>{\n                    self1.fire(\"error\", e);\n                });\n            }\n            callback(self1.$video);\n        });\n    }\n    init() {\n        const self1 = this;\n        self1.playerID = `VideoWorker-${self1.ID}`;\n    }\n    loadAPI() {\n        const self1 = this;\n        if ($4f4d636ec052f8d7$var$YoutubeAPIadded && $4f4d636ec052f8d7$var$VimeoAPIadded) return;\n        let src = \"\";\n        // load Youtube API\n        if (self1.type === \"youtube\" && !$4f4d636ec052f8d7$var$YoutubeAPIadded) {\n            $4f4d636ec052f8d7$var$YoutubeAPIadded = 1;\n            src = \"https://www.youtube.com/iframe_api\";\n        }\n        // load Vimeo API\n        if (self1.type === \"vimeo\" && !$4f4d636ec052f8d7$var$VimeoAPIadded) {\n            $4f4d636ec052f8d7$var$VimeoAPIadded = 1;\n            // Useful when Vimeo API added using RequireJS https://github.com/nk-o/video-worker/pull/7\n            if (typeof $4f4d636ec052f8d7$var$global$1.Vimeo !== \"undefined\") return;\n            src = \"https://player.vimeo.com/api/player.js\";\n        }\n        if (!src) return;\n        // add script in head section\n        let tag = document.createElement(\"script\");\n        let head = document.getElementsByTagName(\"head\")[0];\n        tag.src = src;\n        head.appendChild(tag);\n        head = null;\n        tag = null;\n    }\n    onAPIready(callback) {\n        const self1 = this;\n        // Youtube\n        if (self1.type === \"youtube\") {\n            // Listen for global YT player callback\n            if ((typeof $4f4d636ec052f8d7$var$global$1.YT === \"undefined\" || $4f4d636ec052f8d7$var$global$1.YT.loaded === 0) && !$4f4d636ec052f8d7$var$loadingYoutubePlayer) {\n                // Prevents Ready event from being called twice\n                $4f4d636ec052f8d7$var$loadingYoutubePlayer = 1;\n                // Creates deferred so, other players know when to wait.\n                $4f4d636ec052f8d7$var$global$1.onYouTubeIframeAPIReady = function() {\n                    $4f4d636ec052f8d7$var$global$1.onYouTubeIframeAPIReady = null;\n                    $4f4d636ec052f8d7$var$loadingYoutubeDefer.resolve(\"done\");\n                    callback();\n                };\n            } else if (typeof $4f4d636ec052f8d7$var$global$1.YT === \"object\" && $4f4d636ec052f8d7$var$global$1.YT.loaded === 1) callback();\n            else $4f4d636ec052f8d7$var$loadingYoutubeDefer.done(()=>{\n                callback();\n            });\n        }\n        // Vimeo\n        if (self1.type === \"vimeo\") {\n            if (typeof $4f4d636ec052f8d7$var$global$1.Vimeo === \"undefined\" && !$4f4d636ec052f8d7$var$loadingVimeoPlayer) {\n                $4f4d636ec052f8d7$var$loadingVimeoPlayer = 1;\n                const vimeoInterval = setInterval(()=>{\n                    if (typeof $4f4d636ec052f8d7$var$global$1.Vimeo !== \"undefined\") {\n                        clearInterval(vimeoInterval);\n                        $4f4d636ec052f8d7$var$loadingVimeoDefer.resolve(\"done\");\n                        callback();\n                    }\n                }, 20);\n            } else if (typeof $4f4d636ec052f8d7$var$global$1.Vimeo !== \"undefined\") callback();\n            else $4f4d636ec052f8d7$var$loadingVimeoDefer.done(()=>{\n                callback();\n            });\n        }\n        // Local\n        if (self1.type === \"local\") callback();\n    }\n}\nfunction $4f4d636ec052f8d7$var$jarallaxVideo$1(jarallax = $4f4d636ec052f8d7$var$global$2.jarallax) {\n    if (typeof jarallax === \"undefined\") return;\n    const Jarallax = jarallax.constructor;\n    // append video after when block will be visible.\n    const defOnScroll = Jarallax.prototype.onScroll;\n    Jarallax.prototype.onScroll = function() {\n        const self1 = this;\n        defOnScroll.apply(self1);\n        const isReady = !self1.isVideoInserted && self1.video && (!self1.options.videoLazyLoading || self1.isElementInViewport) && !self1.options.disableVideo();\n        if (isReady) {\n            self1.isVideoInserted = true;\n            self1.video.getVideo((video)=>{\n                const $parent = video.parentNode;\n                self1.css(video, {\n                    position: self1.image.position,\n                    top: \"0px\",\n                    left: \"0px\",\n                    right: \"0px\",\n                    bottom: \"0px\",\n                    width: \"100%\",\n                    height: \"100%\",\n                    maxWidth: \"none\",\n                    maxHeight: \"none\",\n                    pointerEvents: \"none\",\n                    transformStyle: \"preserve-3d\",\n                    backfaceVisibility: \"hidden\",\n                    margin: 0,\n                    zIndex: -1\n                });\n                self1.$video = video;\n                // add Poster attribute to self-hosted video\n                if (self1.video.type === \"local\") {\n                    if (self1.image.src) self1.$video.setAttribute(\"poster\", self1.image.src);\n                    else if (self1.image.$item && self1.image.$item.tagName === \"IMG\" && self1.image.$item.src) self1.$video.setAttribute(\"poster\", self1.image.$item.src);\n                }\n                // add classname to video element\n                if (self1.options.videoClass) self1.$video.setAttribute(\"class\", `${self1.options.videoClass} ${self1.options.videoClass}-${self1.video.type}`);\n                // insert video tag\n                self1.image.$container.appendChild(video);\n                // remove parent video element (created by VideoWorker)\n                $parent.parentNode.removeChild($parent);\n                // call onVideoInsert event\n                if (self1.options.onVideoInsert) self1.options.onVideoInsert.call(self1);\n            });\n        }\n    };\n    // cover video\n    const defCoverImage = Jarallax.prototype.coverImage;\n    Jarallax.prototype.coverImage = function() {\n        const self1 = this;\n        const imageData = defCoverImage.apply(self1);\n        const node = self1.image.$item ? self1.image.$item.nodeName : false;\n        if (imageData && self1.video && node && (node === \"IFRAME\" || node === \"VIDEO\")) {\n            let h = imageData.image.height;\n            let w = h * self1.image.width / self1.image.height;\n            let ml = (imageData.container.width - w) / 2;\n            let mt = imageData.image.marginTop;\n            if (imageData.container.width > w) {\n                w = imageData.container.width;\n                h = w * self1.image.height / self1.image.width;\n                ml = 0;\n                mt += (imageData.image.height - h) / 2;\n            }\n            // add video height over than need to hide controls\n            if (node === \"IFRAME\") {\n                h += 400;\n                mt -= 200;\n            }\n            self1.css(self1.$video, {\n                width: `${w}px`,\n                marginLeft: `${ml}px`,\n                height: `${h}px`,\n                marginTop: `${mt}px`\n            });\n        }\n        return imageData;\n    };\n    // init video\n    const defInitImg = Jarallax.prototype.initImg;\n    Jarallax.prototype.initImg = function() {\n        const self1 = this;\n        const defaultResult = defInitImg.apply(self1);\n        if (!self1.options.videoSrc) self1.options.videoSrc = self1.$item.getAttribute(\"data-jarallax-video\") || null;\n        if (self1.options.videoSrc) {\n            self1.defaultInitImgResult = defaultResult;\n            return true;\n        }\n        return defaultResult;\n    };\n    const defCanInitParallax = Jarallax.prototype.canInitParallax;\n    Jarallax.prototype.canInitParallax = function() {\n        const self1 = this;\n        let defaultResult = defCanInitParallax.apply(self1);\n        if (!self1.options.videoSrc) return defaultResult;\n        // Init video api\n        const video = new $4f4d636ec052f8d7$var$VideoWorker(self1.options.videoSrc, {\n            autoplay: true,\n            loop: self1.options.videoLoop,\n            showControls: false,\n            accessibilityHidden: true,\n            startTime: self1.options.videoStartTime || 0,\n            endTime: self1.options.videoEndTime || 0,\n            mute: !self1.options.videoVolume,\n            volume: self1.options.videoVolume || 0\n        });\n        // call onVideoWorkerInit event\n        if (self1.options.onVideoWorkerInit) self1.options.onVideoWorkerInit.call(self1, video);\n        function resetDefaultImage() {\n            if (self1.image.$default_item) {\n                self1.image.$item = self1.image.$default_item;\n                self1.image.$item.style.display = \"block\";\n                // set image width and height\n                self1.coverImage();\n                self1.onScroll();\n            }\n        }\n        if (video.isValid()) {\n            // Force enable parallax.\n            // When the parallax disabled on mobile devices, we still need to display videos.\n            // https://github.com/nk-o/jarallax/issues/159\n            if (this.options.disableParallax()) {\n                defaultResult = true;\n                self1.image.position = \"absolute\";\n                self1.options.type = \"scroll\";\n                self1.options.speed = 1;\n            }\n            // if parallax will not be inited, we can add thumbnail on background.\n            if (!defaultResult) {\n                if (!self1.defaultInitImgResult) video.getImageURL((url)=>{\n                    // save default user styles\n                    const curStyle = self1.$item.getAttribute(\"style\");\n                    if (curStyle) self1.$item.setAttribute(\"data-jarallax-original-styles\", curStyle);\n                    // set new background\n                    self1.css(self1.$item, {\n                        \"background-image\": `url(\"${url}\")`,\n                        \"background-position\": \"center\",\n                        \"background-size\": \"cover\"\n                    });\n                });\n            } else {\n                video.on(\"ready\", ()=>{\n                    if (self1.options.videoPlayOnlyVisible) {\n                        const oldOnScroll = self1.onScroll;\n                        self1.onScroll = function() {\n                            oldOnScroll.apply(self1);\n                            if (!self1.videoError && (self1.options.videoLoop || !self1.options.videoLoop && !self1.videoEnded)) {\n                                if (self1.isVisible()) video.play();\n                                else video.pause();\n                            }\n                        };\n                    } else video.play();\n                });\n                video.on(\"started\", ()=>{\n                    self1.image.$default_item = self1.image.$item;\n                    self1.image.$item = self1.$video;\n                    // set video width and height\n                    self1.image.width = self1.video.videoWidth || 1280;\n                    self1.image.height = self1.video.videoHeight || 720;\n                    self1.coverImage();\n                    self1.onScroll();\n                    // hide image\n                    if (self1.image.$default_item) self1.image.$default_item.style.display = \"none\";\n                });\n                video.on(\"ended\", ()=>{\n                    self1.videoEnded = true;\n                    if (!self1.options.videoLoop) // show default image if Loop disabled.\n                    resetDefaultImage();\n                });\n                video.on(\"error\", ()=>{\n                    self1.videoError = true;\n                    // show default image if video loading error.\n                    resetDefaultImage();\n                });\n                self1.video = video;\n                // set image if not exists\n                if (!self1.defaultInitImgResult) {\n                    // set empty image on self-hosted video if not defined\n                    self1.image.src = \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\";\n                    if (video.type !== \"local\") {\n                        video.getImageURL((url)=>{\n                            self1.image.bgImage = `url(\"${url}\")`;\n                            self1.init();\n                        });\n                        return false;\n                    }\n                }\n            }\n        }\n        return defaultResult;\n    };\n    // Destroy video parallax\n    const defDestroy = Jarallax.prototype.destroy;\n    Jarallax.prototype.destroy = function() {\n        const self1 = this;\n        if (self1.image.$default_item) {\n            self1.image.$item = self1.image.$default_item;\n            delete self1.image.$default_item;\n        }\n        defDestroy.apply(self1);\n    };\n}\nfunction $4f4d636ec052f8d7$var$jarallaxElement$1(jarallax = $4f4d636ec052f8d7$var$global$2.jarallax) {\n    // eslint-disable-next-line no-console\n    console.warn(\"Jarallax Element extension is DEPRECATED, please, avoid using it. We recommend you look at something like `lax.js` library <https://github.com/alexfoxy/lax.js>. It is much more powerful and has a less code (in cases when you don't want to add parallax backgrounds).\");\n    if (typeof jarallax === \"undefined\") return;\n    const Jarallax = jarallax.constructor;\n    // redefine default methods\n    [\n        \"initImg\",\n        \"canInitParallax\",\n        \"init\",\n        \"destroy\",\n        \"coverImage\",\n        \"isVisible\",\n        \"onScroll\",\n        \"onResize\"\n    ].forEach((key)=>{\n        const def = Jarallax.prototype[key];\n        Jarallax.prototype[key] = function(...args) {\n            const self1 = this;\n            if (key === \"initImg\" && self1.$item.getAttribute(\"data-jarallax-element\") !== null) {\n                self1.options.type = \"element\";\n                self1.pureOptions.speed = self1.$item.getAttribute(\"data-jarallax-element\") || \"100\";\n            }\n            if (self1.options.type !== \"element\") return def.apply(self1, args);\n            self1.pureOptions.threshold = self1.$item.getAttribute(\"data-threshold\") || \"\";\n            switch(key){\n                case \"init\":\n                    {\n                        const speedArr = `${self1.pureOptions.speed}`.split(\" \");\n                        self1.options.speed = self1.pureOptions.speed || 0;\n                        self1.options.speedY = speedArr[0] ? parseFloat(speedArr[0]) : 0;\n                        self1.options.speedX = speedArr[1] ? parseFloat(speedArr[1]) : 0;\n                        const thresholdArr = self1.pureOptions.threshold.split(\" \");\n                        self1.options.thresholdY = thresholdArr[0] ? parseFloat(thresholdArr[0]) : null;\n                        self1.options.thresholdX = thresholdArr[1] ? parseFloat(thresholdArr[1]) : null;\n                        def.apply(self1, args);\n                        // restore background image if available.\n                        const originalStylesTag = self1.$item.getAttribute(\"data-jarallax-original-styles\");\n                        if (originalStylesTag) self1.$item.setAttribute(\"style\", originalStylesTag);\n                        return true;\n                    }\n                case \"onResize\":\n                    {\n                        const defTransform = self1.css(self1.$item, \"transform\");\n                        self1.css(self1.$item, {\n                            transform: \"\"\n                        });\n                        const rect = self1.$item.getBoundingClientRect();\n                        self1.itemData = {\n                            width: rect.width,\n                            height: rect.height,\n                            y: rect.top + self1.getWindowData().y,\n                            x: rect.left\n                        };\n                        self1.css(self1.$item, {\n                            transform: defTransform\n                        });\n                        break;\n                    }\n                case \"onScroll\":\n                    {\n                        const wnd = self1.getWindowData();\n                        const centerPercent = (wnd.y + wnd.height / 2 - self1.itemData.y - self1.itemData.height / 2) / (wnd.height / 2);\n                        const moveY = centerPercent * self1.options.speedY;\n                        const moveX = centerPercent * self1.options.speedX;\n                        let my = moveY;\n                        let mx = moveX;\n                        if (self1.options.thresholdY !== null && moveY > self1.options.thresholdY) my = 0;\n                        if (self1.options.thresholdX !== null && moveX > self1.options.thresholdX) mx = 0;\n                        self1.css(self1.$item, {\n                            transform: `translate3d(${mx}px,${my}px,0)`\n                        });\n                        break;\n                    }\n                case \"initImg\":\n                case \"isVisible\":\n                case \"coverImage\":\n                    return true;\n            }\n            return def.apply(self1, args);\n        };\n    });\n}\nconst $4f4d636ec052f8d7$export$ed67ae96ac85439d = $4f4d636ec052f8d7$var$jarallax$1;\nconst $4f4d636ec052f8d7$export$2d55f99baffb94b = function jarallaxVideo() {\n    return $4f4d636ec052f8d7$var$jarallaxVideo$1($4f4d636ec052f8d7$export$ed67ae96ac85439d);\n};\nconst $4f4d636ec052f8d7$export$63ddba77dade8532 = function jarallaxElement() {\n    return $4f4d636ec052f8d7$var$jarallaxElement$1($4f4d636ec052f8d7$export$ed67ae96ac85439d);\n};\n\n\n\n\n// import the DOM representation of the elements from the page\nvar $b63be9b0371e788c$var$slowJarallaxElements = document.getElementsByClassName(\"jarallax\");\nvar $b63be9b0371e788c$var$fastJarallaxElements = document.getElementsByClassName(\"fastJarallax\");\nvar $b63be9b0371e788c$var$menuBtn = document.getElementById(\"menu-btn\");\nvar $b63be9b0371e788c$var$navCtn = document.getElementById(\"nav-ctn\");\n// initalize the parallax effect using jarallax\n(0, $4f4d636ec052f8d7$export$ed67ae96ac85439d)($b63be9b0371e788c$var$slowJarallaxElements, {\n    speed: 0.3,\n    imgSize: \"cover\"\n});\n(0, $4f4d636ec052f8d7$export$ed67ae96ac85439d)($b63be9b0371e788c$var$fastJarallaxElements, {\n    speed: 0.1\n});\n// add a click listener to the menu btn in order to toggle the nav container ( nav-ctn )\n$b63be9b0371e788c$var$menuBtn.addEventListener(\"click\", function() {\n    $b63be9b0371e788c$var$navCtn.classList.toggle(\"h-max\");\n});\n\n\n//# sourceMappingURL=index.e6e5579d.js.map\n","// import the code dependency( i.e. jarallax )\r\nimport { jarallax } from \"jarallax\";\r\nimport \"jarallax/dist/jarallax.min.css\";\r\nimport \"./style.css\";\r\n\r\n// import the DOM representation of the elements from the page\r\nvar slowJarallaxElements = document.getElementsByClassName(\"jarallax\");\r\nvar fastJarallaxElements = document.getElementsByClassName(\"fastJarallax\");\r\nvar menuBtn = document.getElementById(\"menu-btn\");\r\nvar navCtn = document.getElementById(\"nav-ctn\");\r\n\r\n// initalize the parallax effect using jarallax\r\njarallax( slowJarallaxElements, {\r\n    speed: 0.3,\r\n    imgSize: \"cover\"\r\n});\r\n\r\njarallax( fastJarallaxElements, {\r\n    speed: 0.1,\r\n});\r\n\r\n\r\n\r\n// add a click listener to the menu btn in order to toggle the nav container ( nav-ctn )\r\nmenuBtn.addEventListener( \"click\", function() {\r\n    navCtn.classList.toggle(\"h-max\");\r\n});","/*!\n * Jarallax v2.1.4 (https://github.com/nk-o/jarallax)\n * Copyright 2023 nK <https://nkdev.info>\n * Licensed under MIT (https://github.com/nk-o/jarallax/blob/master/LICENSE)\n */\nvar defaults$1 = {\n  // Base parallax options.\n  type: 'scroll',\n  speed: 0.5,\n  containerClass: 'jarallax-container',\n  imgSrc: null,\n  imgElement: '.jarallax-img',\n  imgSize: 'cover',\n  imgPosition: '50% 50%',\n  imgRepeat: 'no-repeat',\n  keepImg: false,\n  elementInViewport: null,\n  zIndex: -100,\n  disableParallax: false,\n  // Callbacks.\n  onScroll: null,\n  onInit: null,\n  onDestroy: null,\n  onCoverImage: null,\n  // Video options.\n  videoClass: 'jarallax-video',\n  videoSrc: null,\n  videoStartTime: 0,\n  videoEndTime: 0,\n  videoVolume: 0,\n  videoLoop: true,\n  videoPlayOnlyVisible: true,\n  videoLazyLoading: true,\n  disableVideo: false,\n  // Video callbacks.\n  onVideoInsert: null,\n  onVideoWorkerInit: null\n};\n\n/* eslint-disable import/no-mutable-exports */\n/* eslint-disable no-restricted-globals */\nlet win$1;\nif (typeof window !== 'undefined') {\n  win$1 = window;\n} else if (typeof global !== 'undefined') {\n  win$1 = global;\n} else if (typeof self !== 'undefined') {\n  win$1 = self;\n} else {\n  win$1 = {};\n}\nvar global$2 = win$1;\n\n/**\n * Add styles to element.\n *\n * @param {Element} el - element.\n * @param {String|Object} styles - styles list.\n *\n * @returns {Element}\n */\nfunction css(el, styles) {\n  if (typeof styles === 'string') {\n    return global$2.getComputedStyle(el).getPropertyValue(styles);\n  }\n  Object.keys(styles).forEach(key => {\n    el.style[key] = styles[key];\n  });\n  return el;\n}\n\n/**\n * Extend like jQuery.extend\n *\n * @param {Object} out - output object.\n * @param {...any} args - additional objects to extend.\n *\n * @returns {Object}\n */\nfunction extend$1(out, ...args) {\n  out = out || {};\n  Object.keys(args).forEach(i => {\n    if (!args[i]) {\n      return;\n    }\n    Object.keys(args[i]).forEach(key => {\n      out[key] = args[i][key];\n    });\n  });\n  return out;\n}\n\n/**\n * Get all parents of the element.\n *\n * @param {Element} elem - DOM element.\n *\n * @returns {Array}\n */\nfunction getParents(elem) {\n  const parents = [];\n  while (elem.parentElement !== null) {\n    elem = elem.parentElement;\n    if (elem.nodeType === 1) {\n      parents.push(elem);\n    }\n  }\n  return parents;\n}\n\n/**\n * Document ready callback.\n * @param {Function} callback - callback will be fired once Document ready.\n */\nfunction ready(callback) {\n  if (document.readyState === 'complete' || document.readyState === 'interactive') {\n    // Already ready or interactive, execute callback\n    callback();\n  } else {\n    document.addEventListener('DOMContentLoaded', callback, {\n      capture: true,\n      once: true,\n      passive: true\n    });\n  }\n}\n\nconst {\n  navigator: navigator$1\n} = global$2;\nconst mobileAgent = /*#__PURE__*/ /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator$1.userAgent);\nfunction isMobile() {\n  return mobileAgent;\n}\n\nlet wndW;\nlet wndH;\nlet $deviceHelper;\n\n/**\n * The most popular mobile browsers changes height after page scroll and this generates image jumping.\n * We can fix it using this workaround with vh units.\n */\nfunction getDeviceHeight() {\n  if (!$deviceHelper && document.body) {\n    $deviceHelper = document.createElement('div');\n    $deviceHelper.style.cssText = 'position: fixed; top: -9999px; left: 0; height: 100vh; width: 0;';\n    document.body.appendChild($deviceHelper);\n  }\n  return ($deviceHelper ? $deviceHelper.clientHeight : 0) || global$2.innerHeight || document.documentElement.clientHeight;\n}\nfunction updateWindowHeight() {\n  wndW = global$2.innerWidth || document.documentElement.clientWidth;\n  if (isMobile()) {\n    wndH = getDeviceHeight();\n  } else {\n    wndH = global$2.innerHeight || document.documentElement.clientHeight;\n  }\n}\nupdateWindowHeight();\nglobal$2.addEventListener('resize', updateWindowHeight);\nglobal$2.addEventListener('orientationchange', updateWindowHeight);\nglobal$2.addEventListener('load', updateWindowHeight);\nready(() => {\n  updateWindowHeight();\n});\nfunction getWindowSize() {\n  return {\n    width: wndW,\n    height: wndH\n  };\n}\n\n// List with all jarallax instances\n// need to render all in one scroll/resize event.\nconst jarallaxList = [];\nfunction updateParallax() {\n  if (!jarallaxList.length) {\n    return;\n  }\n  const {\n    width: wndW,\n    height: wndH\n  } = getWindowSize();\n  jarallaxList.forEach((data, k) => {\n    const {\n      instance,\n      oldData\n    } = data;\n    if (!instance.isVisible()) {\n      return;\n    }\n    const clientRect = instance.$item.getBoundingClientRect();\n    const newData = {\n      width: clientRect.width,\n      height: clientRect.height,\n      top: clientRect.top,\n      bottom: clientRect.bottom,\n      wndW,\n      wndH\n    };\n    const isResized = !oldData || oldData.wndW !== newData.wndW || oldData.wndH !== newData.wndH || oldData.width !== newData.width || oldData.height !== newData.height;\n    const isScrolled = isResized || !oldData || oldData.top !== newData.top || oldData.bottom !== newData.bottom;\n    jarallaxList[k].oldData = newData;\n    if (isResized) {\n      instance.onResize();\n    }\n    if (isScrolled) {\n      instance.onScroll();\n    }\n  });\n  global$2.requestAnimationFrame(updateParallax);\n}\nconst visibilityObserver = /*#__PURE__*/new global$2.IntersectionObserver(entries => {\n  entries.forEach(entry => {\n    entry.target.jarallax.isElementInViewport = entry.isIntersecting;\n  });\n}, {\n  // We have to start parallax calculation before the block is in view\n  // to prevent possible parallax jumping.\n  rootMargin: '50px'\n});\nfunction addObserver(instance) {\n  jarallaxList.push({\n    instance\n  });\n  if (jarallaxList.length === 1) {\n    global$2.requestAnimationFrame(updateParallax);\n  }\n  visibilityObserver.observe(instance.options.elementInViewport || instance.$item);\n}\nfunction removeObserver(instance) {\n  jarallaxList.forEach((data, key) => {\n    if (data.instance.instanceID === instance.instanceID) {\n      jarallaxList.splice(key, 1);\n    }\n  });\n  visibilityObserver.unobserve(instance.options.elementInViewport || instance.$item);\n}\n\n/* eslint-disable class-methods-use-this */\nconst {\n  navigator\n} = global$2;\nlet instanceID = 0;\n\n// Jarallax class\nclass Jarallax {\n  constructor(item, userOptions) {\n    const self = this;\n    self.instanceID = instanceID;\n    instanceID += 1;\n    self.$item = item;\n    self.defaults = {\n      ...defaults$1\n    };\n\n    // prepare data-options\n    const dataOptions = self.$item.dataset || {};\n    const pureDataOptions = {};\n    Object.keys(dataOptions).forEach(key => {\n      const lowerCaseOption = key.substr(0, 1).toLowerCase() + key.substr(1);\n      if (lowerCaseOption && typeof self.defaults[lowerCaseOption] !== 'undefined') {\n        pureDataOptions[lowerCaseOption] = dataOptions[key];\n      }\n    });\n    self.options = self.extend({}, self.defaults, pureDataOptions, userOptions);\n    self.pureOptions = self.extend({}, self.options);\n\n    // prepare 'true' and 'false' strings to boolean\n    Object.keys(self.options).forEach(key => {\n      if (self.options[key] === 'true') {\n        self.options[key] = true;\n      } else if (self.options[key] === 'false') {\n        self.options[key] = false;\n      }\n    });\n\n    // fix speed option [-1.0, 2.0]\n    self.options.speed = Math.min(2, Math.max(-1, parseFloat(self.options.speed)));\n\n    // prepare disableParallax callback\n    if (typeof self.options.disableParallax === 'string') {\n      self.options.disableParallax = new RegExp(self.options.disableParallax);\n    }\n    if (self.options.disableParallax instanceof RegExp) {\n      const disableParallaxRegexp = self.options.disableParallax;\n      self.options.disableParallax = () => disableParallaxRegexp.test(navigator.userAgent);\n    }\n    if (typeof self.options.disableParallax !== 'function') {\n      self.options.disableParallax = () => false;\n    }\n\n    // prepare disableVideo callback\n    if (typeof self.options.disableVideo === 'string') {\n      self.options.disableVideo = new RegExp(self.options.disableVideo);\n    }\n    if (self.options.disableVideo instanceof RegExp) {\n      const disableVideoRegexp = self.options.disableVideo;\n      self.options.disableVideo = () => disableVideoRegexp.test(navigator.userAgent);\n    }\n    if (typeof self.options.disableVideo !== 'function') {\n      self.options.disableVideo = () => false;\n    }\n\n    // custom element to check if parallax in viewport\n    let elementInVP = self.options.elementInViewport;\n    // get first item from array\n    if (elementInVP && typeof elementInVP === 'object' && typeof elementInVP.length !== 'undefined') {\n      [elementInVP] = elementInVP;\n    }\n    // check if dom element\n    if (!(elementInVP instanceof Element)) {\n      elementInVP = null;\n    }\n    self.options.elementInViewport = elementInVP;\n    self.image = {\n      src: self.options.imgSrc || null,\n      $container: null,\n      useImgTag: false,\n      // 1. Position fixed is needed for the most of browsers because absolute position have glitches\n      // 2. On MacOS with smooth scroll there is a huge lags with absolute position - https://github.com/nk-o/jarallax/issues/75\n      // 3. Previously used 'absolute' for mobile devices. But we re-tested on iPhone 12 and 'fixed' position is working better, then 'absolute', so for now position is always 'fixed'\n      position: 'fixed'\n    };\n    if (self.initImg() && self.canInitParallax()) {\n      self.init();\n    }\n  }\n  css(el, styles) {\n    return css(el, styles);\n  }\n  extend(out, ...args) {\n    return extend$1(out, ...args);\n  }\n\n  // get window size and scroll position. Useful for extensions\n  getWindowData() {\n    const {\n      width,\n      height\n    } = getWindowSize();\n    return {\n      width,\n      height,\n      y: document.documentElement.scrollTop\n    };\n  }\n\n  // Jarallax functions\n  initImg() {\n    const self = this;\n\n    // find image element\n    let $imgElement = self.options.imgElement;\n    if ($imgElement && typeof $imgElement === 'string') {\n      $imgElement = self.$item.querySelector($imgElement);\n    }\n\n    // check if dom element\n    if (!($imgElement instanceof Element)) {\n      if (self.options.imgSrc) {\n        $imgElement = new Image();\n        $imgElement.src = self.options.imgSrc;\n      } else {\n        $imgElement = null;\n      }\n    }\n    if ($imgElement) {\n      if (self.options.keepImg) {\n        self.image.$item = $imgElement.cloneNode(true);\n      } else {\n        self.image.$item = $imgElement;\n        self.image.$itemParent = $imgElement.parentNode;\n      }\n      self.image.useImgTag = true;\n    }\n\n    // true if there is img tag\n    if (self.image.$item) {\n      return true;\n    }\n\n    // get image src\n    if (self.image.src === null) {\n      self.image.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';\n      self.image.bgImage = self.css(self.$item, 'background-image');\n    }\n    return !(!self.image.bgImage || self.image.bgImage === 'none');\n  }\n  canInitParallax() {\n    return !this.options.disableParallax();\n  }\n  init() {\n    const self = this;\n    const containerStyles = {\n      position: 'absolute',\n      top: 0,\n      left: 0,\n      width: '100%',\n      height: '100%',\n      overflow: 'hidden'\n    };\n    let imageStyles = {\n      pointerEvents: 'none',\n      transformStyle: 'preserve-3d',\n      backfaceVisibility: 'hidden'\n    };\n    if (!self.options.keepImg) {\n      // save default user styles\n      const curStyle = self.$item.getAttribute('style');\n      if (curStyle) {\n        self.$item.setAttribute('data-jarallax-original-styles', curStyle);\n      }\n      if (self.image.useImgTag) {\n        const curImgStyle = self.image.$item.getAttribute('style');\n        if (curImgStyle) {\n          self.image.$item.setAttribute('data-jarallax-original-styles', curImgStyle);\n        }\n      }\n    }\n\n    // set relative position and z-index to the parent\n    if (self.css(self.$item, 'position') === 'static') {\n      self.css(self.$item, {\n        position: 'relative'\n      });\n    }\n    if (self.css(self.$item, 'z-index') === 'auto') {\n      self.css(self.$item, {\n        zIndex: 0\n      });\n    }\n\n    // container for parallax image\n    self.image.$container = document.createElement('div');\n    self.css(self.image.$container, containerStyles);\n    self.css(self.image.$container, {\n      'z-index': self.options.zIndex\n    });\n\n    // it will remove some image overlapping\n    // overlapping occur due to an image position fixed inside absolute position element\n    // needed only when background in fixed position\n    if (this.image.position === 'fixed') {\n      self.css(self.image.$container, {\n        '-webkit-clip-path': 'polygon(0 0, 100% 0, 100% 100%, 0 100%)',\n        'clip-path': 'polygon(0 0, 100% 0, 100% 100%, 0 100%)'\n      });\n    }\n\n    // Add container unique ID.\n    self.image.$container.setAttribute('id', `jarallax-container-${self.instanceID}`);\n\n    // Add container class.\n    if (self.options.containerClass) {\n      self.image.$container.setAttribute('class', self.options.containerClass);\n    }\n    self.$item.appendChild(self.image.$container);\n\n    // use img tag\n    if (self.image.useImgTag) {\n      imageStyles = self.extend({\n        'object-fit': self.options.imgSize,\n        'object-position': self.options.imgPosition,\n        'max-width': 'none'\n      }, containerStyles, imageStyles);\n\n      // use div with background image\n    } else {\n      self.image.$item = document.createElement('div');\n      if (self.image.src) {\n        imageStyles = self.extend({\n          'background-position': self.options.imgPosition,\n          'background-size': self.options.imgSize,\n          'background-repeat': self.options.imgRepeat,\n          'background-image': self.image.bgImage || `url(\"${self.image.src}\")`\n        }, containerStyles, imageStyles);\n      }\n    }\n    if (self.options.type === 'opacity' || self.options.type === 'scale' || self.options.type === 'scale-opacity' || self.options.speed === 1) {\n      self.image.position = 'absolute';\n    }\n\n    // 1. Check if one of parents have transform style (without this check, scroll transform will be inverted if used parallax with position fixed)\n    //    discussion - https://github.com/nk-o/jarallax/issues/9\n    // 2. Check if parents have overflow scroll\n    if (self.image.position === 'fixed') {\n      const $parents = getParents(self.$item).filter(el => {\n        const styles = global$2.getComputedStyle(el);\n        const parentTransform = styles['-webkit-transform'] || styles['-moz-transform'] || styles.transform;\n        const overflowRegex = /(auto|scroll)/;\n        return parentTransform && parentTransform !== 'none' || overflowRegex.test(styles.overflow + styles['overflow-y'] + styles['overflow-x']);\n      });\n      self.image.position = $parents.length ? 'absolute' : 'fixed';\n    }\n\n    // add position to parallax block\n    imageStyles.position = self.image.position;\n\n    // insert parallax image\n    self.css(self.image.$item, imageStyles);\n    self.image.$container.appendChild(self.image.$item);\n\n    // set initial position and size\n    self.onResize();\n    self.onScroll(true);\n\n    // call onInit event\n    if (self.options.onInit) {\n      self.options.onInit.call(self);\n    }\n\n    // remove default user background\n    if (self.css(self.$item, 'background-image') !== 'none') {\n      self.css(self.$item, {\n        'background-image': 'none'\n      });\n    }\n    addObserver(self);\n  }\n  destroy() {\n    const self = this;\n    removeObserver(self);\n\n    // return styles on container as before jarallax init\n    const originalStylesTag = self.$item.getAttribute('data-jarallax-original-styles');\n    self.$item.removeAttribute('data-jarallax-original-styles');\n    // null occurs if there is no style tag before jarallax init\n    if (!originalStylesTag) {\n      self.$item.removeAttribute('style');\n    } else {\n      self.$item.setAttribute('style', originalStylesTag);\n    }\n    if (self.image.useImgTag) {\n      // return styles on img tag as before jarallax init\n      const originalStylesImgTag = self.image.$item.getAttribute('data-jarallax-original-styles');\n      self.image.$item.removeAttribute('data-jarallax-original-styles');\n      // null occurs if there is no style tag before jarallax init\n      if (!originalStylesImgTag) {\n        self.image.$item.removeAttribute('style');\n      } else {\n        self.image.$item.setAttribute('style', originalStylesTag);\n      }\n\n      // move img tag to its default position\n      if (self.image.$itemParent) {\n        self.image.$itemParent.appendChild(self.image.$item);\n      }\n    }\n\n    // remove additional dom elements\n    if (self.image.$container) {\n      self.image.$container.parentNode.removeChild(self.image.$container);\n    }\n\n    // call onDestroy event\n    if (self.options.onDestroy) {\n      self.options.onDestroy.call(self);\n    }\n\n    // delete jarallax from item\n    delete self.$item.jarallax;\n  }\n  coverImage() {\n    const self = this;\n    const {\n      height: wndH\n    } = getWindowSize();\n    const rect = self.image.$container.getBoundingClientRect();\n    const contH = rect.height;\n    const {\n      speed\n    } = self.options;\n    const isScroll = self.options.type === 'scroll' || self.options.type === 'scroll-opacity';\n    let scrollDist = 0;\n    let resultH = contH;\n    let resultMT = 0;\n\n    // scroll parallax\n    if (isScroll) {\n      // scroll distance and height for image\n      if (speed < 0) {\n        scrollDist = speed * Math.max(contH, wndH);\n        if (wndH < contH) {\n          scrollDist -= speed * (contH - wndH);\n        }\n      } else {\n        scrollDist = speed * (contH + wndH);\n      }\n\n      // size for scroll parallax\n      if (speed > 1) {\n        resultH = Math.abs(scrollDist - wndH);\n      } else if (speed < 0) {\n        resultH = scrollDist / speed + Math.abs(scrollDist);\n      } else {\n        resultH += (wndH - contH) * (1 - speed);\n      }\n      scrollDist /= 2;\n    }\n\n    // store scroll distance\n    self.parallaxScrollDistance = scrollDist;\n\n    // vertical center\n    if (isScroll) {\n      resultMT = (wndH - resultH) / 2;\n    } else {\n      resultMT = (contH - resultH) / 2;\n    }\n\n    // apply result to item\n    self.css(self.image.$item, {\n      height: `${resultH}px`,\n      marginTop: `${resultMT}px`,\n      left: self.image.position === 'fixed' ? `${rect.left}px` : '0',\n      width: `${rect.width}px`\n    });\n\n    // call onCoverImage event\n    if (self.options.onCoverImage) {\n      self.options.onCoverImage.call(self);\n    }\n\n    // return some useful data. Used in the video cover function\n    return {\n      image: {\n        height: resultH,\n        marginTop: resultMT\n      },\n      container: rect\n    };\n  }\n  isVisible() {\n    return this.isElementInViewport || false;\n  }\n  onScroll(force) {\n    const self = this;\n\n    // stop calculations if item is not in viewport\n    if (!force && !self.isVisible()) {\n      return;\n    }\n    const {\n      height: wndH\n    } = getWindowSize();\n    const rect = self.$item.getBoundingClientRect();\n    const contT = rect.top;\n    const contH = rect.height;\n    const styles = {};\n\n    // calculate parallax helping variables\n    const beforeTop = Math.max(0, contT);\n    const beforeTopEnd = Math.max(0, contH + contT);\n    const afterTop = Math.max(0, -contT);\n    const beforeBottom = Math.max(0, contT + contH - wndH);\n    const beforeBottomEnd = Math.max(0, contH - (contT + contH - wndH));\n    const afterBottom = Math.max(0, -contT + wndH - contH);\n    const fromViewportCenter = 1 - 2 * ((wndH - contT) / (wndH + contH));\n\n    // calculate on how percent of section is visible\n    let visiblePercent = 1;\n    if (contH < wndH) {\n      visiblePercent = 1 - (afterTop || beforeBottom) / contH;\n    } else if (beforeTopEnd <= wndH) {\n      visiblePercent = beforeTopEnd / wndH;\n    } else if (beforeBottomEnd <= wndH) {\n      visiblePercent = beforeBottomEnd / wndH;\n    }\n\n    // opacity\n    if (self.options.type === 'opacity' || self.options.type === 'scale-opacity' || self.options.type === 'scroll-opacity') {\n      styles.transform = 'translate3d(0,0,0)';\n      styles.opacity = visiblePercent;\n    }\n\n    // scale\n    if (self.options.type === 'scale' || self.options.type === 'scale-opacity') {\n      let scale = 1;\n      if (self.options.speed < 0) {\n        scale -= self.options.speed * visiblePercent;\n      } else {\n        scale += self.options.speed * (1 - visiblePercent);\n      }\n      styles.transform = `scale(${scale}) translate3d(0,0,0)`;\n    }\n\n    // scroll\n    if (self.options.type === 'scroll' || self.options.type === 'scroll-opacity') {\n      let positionY = self.parallaxScrollDistance * fromViewportCenter;\n\n      // fix if parallax block in absolute position\n      if (self.image.position === 'absolute') {\n        positionY -= contT;\n      }\n      styles.transform = `translate3d(0,${positionY}px,0)`;\n    }\n    self.css(self.image.$item, styles);\n\n    // call onScroll event\n    if (self.options.onScroll) {\n      self.options.onScroll.call(self, {\n        section: rect,\n        beforeTop,\n        beforeTopEnd,\n        afterTop,\n        beforeBottom,\n        beforeBottomEnd,\n        afterBottom,\n        visiblePercent,\n        fromViewportCenter\n      });\n    }\n  }\n  onResize() {\n    this.coverImage();\n  }\n}\n\n// global definition\nconst jarallax$1 = function (items, options, ...args) {\n  // check for dom element\n  // thanks: http://stackoverflow.com/questions/384286/javascript-isdom-how-do-you-check-if-a-javascript-object-is-a-dom-object\n  if (typeof HTMLElement === 'object' ? items instanceof HTMLElement : items && typeof items === 'object' && items !== null && items.nodeType === 1 && typeof items.nodeName === 'string') {\n    items = [items];\n  }\n  const len = items.length;\n  let k = 0;\n  let ret;\n  for (k; k < len; k += 1) {\n    if (typeof options === 'object' || typeof options === 'undefined') {\n      if (!items[k].jarallax) {\n        items[k].jarallax = new Jarallax(items[k], options);\n      }\n    } else if (items[k].jarallax) {\n      // eslint-disable-next-line prefer-spread\n      ret = items[k].jarallax[options].apply(items[k].jarallax, args);\n    }\n    if (typeof ret !== 'undefined') {\n      return ret;\n    }\n  }\n  return items;\n};\njarallax$1.constructor = Jarallax;\n\n/*!\n * Video Worker v2.1.5 (https://github.com/nk-o/video-worker)\n * Copyright 2022 nK <https://nkdev.info>\n * Licensed under MIT (https://github.com/nk-o/video-worker/blob/master/LICENSE)\n */\n\n/* eslint-disable import/no-mutable-exports */\n/* eslint-disable no-restricted-globals */\nlet win;\nif (typeof window !== 'undefined') {\n  win = window;\n} else if (typeof global !== 'undefined') {\n  win = global;\n} else if (typeof self !== 'undefined') {\n  win = self;\n} else {\n  win = {};\n}\nvar global$1 = win;\n\n// Deferred\n// thanks http://stackoverflow.com/questions/18096715/implement-deferred-object-without-using-jquery\nfunction Deferred() {\n  this.doneCallbacks = [];\n  this.failCallbacks = [];\n}\nDeferred.prototype = {\n  execute(list, args) {\n    let i = list.length;\n    // eslint-disable-next-line no-param-reassign\n    args = Array.prototype.slice.call(args);\n    while (i) {\n      i -= 1;\n      list[i].apply(null, args);\n    }\n  },\n  resolve(...args) {\n    this.execute(this.doneCallbacks, args);\n  },\n  reject(...args) {\n    this.execute(this.failCallbacks, args);\n  },\n  done(callback) {\n    this.doneCallbacks.push(callback);\n  },\n  fail(callback) {\n    this.failCallbacks.push(callback);\n  }\n};\nvar defaults = {\n  autoplay: false,\n  loop: false,\n  mute: false,\n  volume: 100,\n  showControls: true,\n  accessibilityHidden: false,\n  // start / end video time in seconds\n  startTime: 0,\n  endTime: 0\n};\n\n/**\n * Extend like jQuery.extend\n *\n * @param {Object} out - output object.\n * @param {...any} args - additional objects to extend.\n *\n * @returns {Object}\n */\nfunction extend(out, ...args) {\n  out = out || {};\n  Object.keys(args).forEach(i => {\n    if (!args[i]) {\n      return;\n    }\n    Object.keys(args[i]).forEach(key => {\n      out[key] = args[i][key];\n    });\n  });\n  return out;\n}\nlet ID = 0;\nlet YoutubeAPIadded = 0;\nlet VimeoAPIadded = 0;\nlet loadingYoutubePlayer = 0;\nlet loadingVimeoPlayer = 0;\nconst loadingYoutubeDefer = /*#__PURE__*/new Deferred();\nconst loadingVimeoDefer = /*#__PURE__*/new Deferred();\nclass VideoWorker {\n  constructor(url, options) {\n    const self = this;\n    self.url = url;\n    self.options_default = {\n      ...defaults\n    };\n    self.options = extend({}, self.options_default, options);\n\n    // check URL\n    self.videoID = self.parseURL(url);\n\n    // init\n    if (self.videoID) {\n      self.ID = ID;\n      ID += 1;\n      self.loadAPI();\n      self.init();\n    }\n  }\n  parseURL(url) {\n    // parse youtube ID\n    function getYoutubeID(ytUrl) {\n      // eslint-disable-next-line no-useless-escape\n      const regExp = /.*(?:youtu.be\\/|v\\/|u\\/\\w\\/|embed\\/|shorts\\/|watch\\?v=)([^#\\&\\?]*).*/;\n      const match = ytUrl.match(regExp);\n      return match && match[1].length === 11 ? match[1] : false;\n    }\n\n    // parse vimeo ID\n    function getVimeoID(vmUrl) {\n      // eslint-disable-next-line no-useless-escape\n      const regExp = /https?:\\/\\/(?:www\\.|player\\.)?vimeo.com\\/(?:channels\\/(?:\\w+\\/)?|groups\\/([^/]*)\\/videos\\/|album\\/(\\d+)\\/video\\/|video\\/|)(\\d+)(?:$|\\/|\\?)/;\n      const match = vmUrl.match(regExp);\n      return match && match[3] ? match[3] : false;\n    }\n\n    // parse local string\n    function getLocalVideos(locUrl) {\n      // eslint-disable-next-line no-useless-escape\n      const videoFormats = locUrl.split(/,(?=mp4\\:|webm\\:|ogv\\:|ogg\\:)/);\n      const result = {};\n      let ready = 0;\n      videoFormats.forEach(val => {\n        // eslint-disable-next-line no-useless-escape\n        const match = val.match(/^(mp4|webm|ogv|ogg)\\:(.*)/);\n        if (match && match[1] && match[2]) {\n          // eslint-disable-next-line prefer-destructuring\n          result[match[1] === 'ogv' ? 'ogg' : match[1]] = match[2];\n          ready = 1;\n        }\n      });\n      return ready ? result : false;\n    }\n    const Youtube = getYoutubeID(url);\n    const Vimeo = getVimeoID(url);\n    const Local = getLocalVideos(url);\n    if (Youtube) {\n      this.type = 'youtube';\n      return Youtube;\n    }\n    if (Vimeo) {\n      this.type = 'vimeo';\n      return Vimeo;\n    }\n    if (Local) {\n      this.type = 'local';\n      return Local;\n    }\n    return false;\n  }\n  isValid() {\n    return !!this.videoID;\n  }\n\n  // events\n  on(name, callback) {\n    this.userEventsList = this.userEventsList || [];\n\n    // add new callback in events list\n    (this.userEventsList[name] || (this.userEventsList[name] = [])).push(callback);\n  }\n  off(name, callback) {\n    if (!this.userEventsList || !this.userEventsList[name]) {\n      return;\n    }\n    if (!callback) {\n      delete this.userEventsList[name];\n    } else {\n      this.userEventsList[name].forEach((val, key) => {\n        if (val === callback) {\n          this.userEventsList[name][key] = false;\n        }\n      });\n    }\n  }\n  fire(name, ...args) {\n    if (this.userEventsList && typeof this.userEventsList[name] !== 'undefined') {\n      this.userEventsList[name].forEach(val => {\n        // call with all arguments\n        if (val) {\n          val.apply(this, args);\n        }\n      });\n    }\n  }\n  play(start) {\n    const self = this;\n    if (!self.player) {\n      return;\n    }\n    if (self.type === 'youtube' && self.player.playVideo) {\n      if (typeof start !== 'undefined') {\n        self.player.seekTo(start || 0);\n      }\n      if (global$1.YT.PlayerState.PLAYING !== self.player.getPlayerState()) {\n        self.player.playVideo();\n      }\n    }\n    if (self.type === 'vimeo') {\n      if (typeof start !== 'undefined') {\n        self.player.setCurrentTime(start);\n      }\n      self.player.getPaused().then(paused => {\n        if (paused) {\n          self.player.play();\n        }\n      });\n    }\n    if (self.type === 'local') {\n      if (typeof start !== 'undefined') {\n        self.player.currentTime = start;\n      }\n      if (self.player.paused) {\n        self.player.play();\n      }\n    }\n  }\n  pause() {\n    const self = this;\n    if (!self.player) {\n      return;\n    }\n    if (self.type === 'youtube' && self.player.pauseVideo) {\n      if (global$1.YT.PlayerState.PLAYING === self.player.getPlayerState()) {\n        self.player.pauseVideo();\n      }\n    }\n    if (self.type === 'vimeo') {\n      self.player.getPaused().then(paused => {\n        if (!paused) {\n          self.player.pause();\n        }\n      });\n    }\n    if (self.type === 'local') {\n      if (!self.player.paused) {\n        self.player.pause();\n      }\n    }\n  }\n  mute() {\n    const self = this;\n    if (!self.player) {\n      return;\n    }\n    if (self.type === 'youtube' && self.player.mute) {\n      self.player.mute();\n    }\n    if (self.type === 'vimeo' && self.player.setVolume) {\n      self.setVolume(0);\n    }\n    if (self.type === 'local') {\n      self.$video.muted = true;\n    }\n  }\n  unmute() {\n    const self = this;\n    if (!self.player) {\n      return;\n    }\n    if (self.type === 'youtube' && self.player.mute) {\n      self.player.unMute();\n    }\n    if (self.type === 'vimeo' && self.player.setVolume) {\n      // In case the default volume is 0, we have to set 100 when unmute.\n      self.setVolume(self.options.volume || 100);\n    }\n    if (self.type === 'local') {\n      self.$video.muted = false;\n    }\n  }\n  setVolume(volume = false) {\n    const self = this;\n    if (!self.player || typeof volume !== 'number') {\n      return;\n    }\n    if (self.type === 'youtube' && self.player.setVolume) {\n      self.player.setVolume(volume);\n    }\n    if (self.type === 'vimeo' && self.player.setVolume) {\n      self.player.setVolume(volume / 100);\n    }\n    if (self.type === 'local') {\n      self.$video.volume = volume / 100;\n    }\n  }\n  getVolume(callback) {\n    const self = this;\n    if (!self.player) {\n      callback(false);\n      return;\n    }\n    if (self.type === 'youtube' && self.player.getVolume) {\n      callback(self.player.getVolume());\n    }\n    if (self.type === 'vimeo' && self.player.getVolume) {\n      self.player.getVolume().then(volume => {\n        callback(volume * 100);\n      });\n    }\n    if (self.type === 'local') {\n      callback(self.$video.volume * 100);\n    }\n  }\n  getMuted(callback) {\n    const self = this;\n    if (!self.player) {\n      callback(null);\n      return;\n    }\n    if (self.type === 'youtube' && self.player.isMuted) {\n      callback(self.player.isMuted());\n    }\n    if (self.type === 'vimeo' && self.player.getVolume) {\n      self.player.getVolume().then(volume => {\n        callback(!!volume);\n      });\n    }\n    if (self.type === 'local') {\n      callback(self.$video.muted);\n    }\n  }\n  getImageURL(callback) {\n    const self = this;\n    if (self.videoImage) {\n      callback(self.videoImage);\n      return;\n    }\n    if (self.type === 'youtube') {\n      const availableSizes = ['maxresdefault', 'sddefault', 'hqdefault', '0'];\n      let step = 0;\n      const tempImg = new Image();\n      tempImg.onload = function () {\n        // if no thumbnail, youtube add their own image with width = 120px\n        if ((this.naturalWidth || this.width) !== 120 || step === availableSizes.length - 1) {\n          // ok\n          self.videoImage = `https://img.youtube.com/vi/${self.videoID}/${availableSizes[step]}.jpg`;\n          callback(self.videoImage);\n        } else {\n          // try another size\n          step += 1;\n          this.src = `https://img.youtube.com/vi/${self.videoID}/${availableSizes[step]}.jpg`;\n        }\n      };\n      tempImg.src = `https://img.youtube.com/vi/${self.videoID}/${availableSizes[step]}.jpg`;\n    }\n    if (self.type === 'vimeo') {\n      // We should provide width to get HQ thumbnail URL.\n      let width = global$1.innerWidth || 1920;\n      if (global$1.devicePixelRatio) {\n        width *= global$1.devicePixelRatio;\n      }\n      width = Math.min(width, 1920);\n      let request = new XMLHttpRequest();\n      // https://vimeo.com/api/oembed.json?url=https://vimeo.com/235212527\n      request.open('GET', `https://vimeo.com/api/oembed.json?url=${self.url}&width=${width}`, true);\n      request.onreadystatechange = function () {\n        if (this.readyState === 4) {\n          if (this.status >= 200 && this.status < 400) {\n            // Success!\n            const response = JSON.parse(this.responseText);\n            if (response.thumbnail_url) {\n              self.videoImage = response.thumbnail_url;\n              callback(self.videoImage);\n            }\n          }\n        }\n      };\n      request.send();\n      request = null;\n    }\n  }\n\n  // fallback to the old version.\n  getIframe(callback) {\n    this.getVideo(callback);\n  }\n  getVideo(callback) {\n    const self = this;\n\n    // return generated video block\n    if (self.$video) {\n      callback(self.$video);\n      return;\n    }\n\n    // generate new video block\n    self.onAPIready(() => {\n      let hiddenDiv;\n      if (!self.$video) {\n        hiddenDiv = document.createElement('div');\n        hiddenDiv.style.display = 'none';\n      }\n\n      // Youtube\n      if (self.type === 'youtube') {\n        self.playerOptions = {\n          // GDPR Compliance.\n          host: 'https://www.youtube-nocookie.com',\n          videoId: self.videoID,\n          playerVars: {\n            autohide: 1,\n            rel: 0,\n            autoplay: 0,\n            // autoplay enable on mobile devices\n            playsinline: 1\n          }\n        };\n\n        // hide controls\n        if (!self.options.showControls) {\n          self.playerOptions.playerVars.iv_load_policy = 3;\n          self.playerOptions.playerVars.modestbranding = 1;\n          self.playerOptions.playerVars.controls = 0;\n          self.playerOptions.playerVars.showinfo = 0;\n          self.playerOptions.playerVars.disablekb = 1;\n        }\n\n        // events\n        let ytStarted;\n        let ytProgressInterval;\n        self.playerOptions.events = {\n          onReady(e) {\n            // mute\n            if (self.options.mute) {\n              e.target.mute();\n            } else if (typeof self.options.volume === 'number') {\n              e.target.setVolume(self.options.volume);\n            }\n\n            // autoplay\n            if (self.options.autoplay) {\n              self.play(self.options.startTime);\n            }\n            self.fire('ready', e);\n\n            // For seamless loops, set the endTime to 0.1 seconds less than the video's duration\n            // https://github.com/nk-o/video-worker/issues/2\n            if (self.options.loop && !self.options.endTime) {\n              const secondsOffset = 0.1;\n              self.options.endTime = self.player.getDuration() - secondsOffset;\n            }\n\n            // volumechange\n            setInterval(() => {\n              self.getVolume(volume => {\n                if (self.options.volume !== volume) {\n                  self.options.volume = volume;\n                  self.fire('volumechange', e);\n                }\n              });\n            }, 150);\n          },\n          onStateChange(e) {\n            // loop\n            if (self.options.loop && e.data === global$1.YT.PlayerState.ENDED) {\n              self.play(self.options.startTime);\n            }\n            if (!ytStarted && e.data === global$1.YT.PlayerState.PLAYING) {\n              ytStarted = 1;\n              self.fire('started', e);\n            }\n            if (e.data === global$1.YT.PlayerState.PLAYING) {\n              self.fire('play', e);\n            }\n            if (e.data === global$1.YT.PlayerState.PAUSED) {\n              self.fire('pause', e);\n            }\n            if (e.data === global$1.YT.PlayerState.ENDED) {\n              self.fire('ended', e);\n            }\n\n            // progress check\n            if (e.data === global$1.YT.PlayerState.PLAYING) {\n              ytProgressInterval = setInterval(() => {\n                self.fire('timeupdate', e);\n\n                // check for end of video and play again or stop\n                if (self.options.endTime && self.player.getCurrentTime() >= self.options.endTime) {\n                  if (self.options.loop) {\n                    self.play(self.options.startTime);\n                  } else {\n                    self.pause();\n                  }\n                }\n              }, 150);\n            } else {\n              clearInterval(ytProgressInterval);\n            }\n          },\n          onError(e) {\n            self.fire('error', e);\n          }\n        };\n        const firstInit = !self.$video;\n        if (firstInit) {\n          const div = document.createElement('div');\n          div.setAttribute('id', self.playerID);\n          hiddenDiv.appendChild(div);\n          document.body.appendChild(hiddenDiv);\n        }\n        self.player = self.player || new global$1.YT.Player(self.playerID, self.playerOptions);\n        if (firstInit) {\n          self.$video = document.getElementById(self.playerID);\n\n          // add accessibility attributes\n          if (self.options.accessibilityHidden) {\n            self.$video.setAttribute('tabindex', '-1');\n            self.$video.setAttribute('aria-hidden', 'true');\n          }\n\n          // get video width and height\n          self.videoWidth = parseInt(self.$video.getAttribute('width'), 10) || 1280;\n          self.videoHeight = parseInt(self.$video.getAttribute('height'), 10) || 720;\n        }\n      }\n\n      // Vimeo\n      if (self.type === 'vimeo') {\n        self.playerOptions = {\n          // GDPR Compliance.\n          dnt: 1,\n          id: self.videoID,\n          autopause: 0,\n          transparent: 0,\n          autoplay: self.options.autoplay ? 1 : 0,\n          loop: self.options.loop ? 1 : 0,\n          muted: self.options.mute || self.options.volume === 0 ? 1 : 0\n        };\n\n        // hide controls\n        if (!self.options.showControls) {\n          self.playerOptions.controls = 0;\n        }\n\n        // enable background option\n        if (!self.options.showControls && self.options.loop && self.options.autoplay) {\n          self.playerOptions.background = 1;\n        }\n        if (!self.$video) {\n          let playerOptionsString = '';\n          Object.keys(self.playerOptions).forEach(key => {\n            if (playerOptionsString !== '') {\n              playerOptionsString += '&';\n            }\n            playerOptionsString += `${key}=${encodeURIComponent(self.playerOptions[key])}`;\n          });\n\n          // we need to create iframe manually because when we create it using API\n          // js events won't triggers after iframe moved to another place\n          self.$video = document.createElement('iframe');\n          self.$video.setAttribute('id', self.playerID);\n          self.$video.setAttribute('src', `https://player.vimeo.com/video/${self.videoID}?${playerOptionsString}`);\n          self.$video.setAttribute('frameborder', '0');\n          self.$video.setAttribute('mozallowfullscreen', '');\n          self.$video.setAttribute('allowfullscreen', '');\n          self.$video.setAttribute('title', 'Vimeo video player');\n\n          // add accessibility attributes\n          if (self.options.accessibilityHidden) {\n            self.$video.setAttribute('tabindex', '-1');\n            self.$video.setAttribute('aria-hidden', 'true');\n          }\n          hiddenDiv.appendChild(self.$video);\n          document.body.appendChild(hiddenDiv);\n        }\n        self.player = self.player || new global$1.Vimeo.Player(self.$video, self.playerOptions);\n\n        // Since Vimeo removed the `volume` parameter, we have to set it manually.\n        if (!self.options.mute && typeof self.options.volume === 'number') {\n          self.setVolume(self.options.volume);\n        }\n\n        // set current time for autoplay\n        if (self.options.startTime && self.options.autoplay) {\n          self.player.setCurrentTime(self.options.startTime);\n        }\n\n        // get video width and height\n        self.player.getVideoWidth().then(width => {\n          self.videoWidth = width || 1280;\n        });\n        self.player.getVideoHeight().then(height => {\n          self.videoHeight = height || 720;\n        });\n\n        // events\n        let vmStarted;\n        self.player.on('timeupdate', e => {\n          if (!vmStarted) {\n            self.fire('started', e);\n            vmStarted = 1;\n          }\n          self.fire('timeupdate', e);\n\n          // check for end of video and play again or stop\n          if (self.options.endTime) {\n            if (self.options.endTime && e.seconds >= self.options.endTime) {\n              if (self.options.loop) {\n                self.play(self.options.startTime);\n              } else {\n                self.pause();\n              }\n            }\n          }\n        });\n        self.player.on('play', e => {\n          self.fire('play', e);\n\n          // check for the start time and start with it\n          if (self.options.startTime && e.seconds === 0) {\n            self.play(self.options.startTime);\n          }\n        });\n        self.player.on('pause', e => {\n          self.fire('pause', e);\n        });\n        self.player.on('ended', e => {\n          self.fire('ended', e);\n        });\n        self.player.on('loaded', e => {\n          self.fire('ready', e);\n        });\n        self.player.on('volumechange', e => {\n          self.getVolume(volume => {\n            self.options.volume = volume;\n          });\n          self.fire('volumechange', e);\n        });\n        self.player.on('error', e => {\n          self.fire('error', e);\n        });\n      }\n\n      // Local\n      function addSourceToLocal(element, src, type) {\n        const source = document.createElement('source');\n        source.src = src;\n        source.type = type;\n        element.appendChild(source);\n      }\n      if (self.type === 'local') {\n        if (!self.$video) {\n          self.$video = document.createElement('video');\n          self.player = self.$video;\n\n          // show controls\n          if (self.options.showControls) {\n            self.$video.controls = true;\n          }\n\n          // set volume\n          if (typeof self.options.volume === 'number') {\n            self.setVolume(self.options.volume);\n          }\n\n          // mute (it is required to mute after the volume set)\n          if (self.options.mute) {\n            self.mute();\n          }\n\n          // loop\n          if (self.options.loop) {\n            self.$video.loop = true;\n          }\n\n          // autoplay enable on mobile devices\n          self.$video.setAttribute('playsinline', '');\n          self.$video.setAttribute('webkit-playsinline', '');\n\n          // add accessibility attributes\n          if (self.options.accessibilityHidden) {\n            self.$video.setAttribute('tabindex', '-1');\n            self.$video.setAttribute('aria-hidden', 'true');\n          }\n          self.$video.setAttribute('id', self.playerID);\n          hiddenDiv.appendChild(self.$video);\n          document.body.appendChild(hiddenDiv);\n          Object.keys(self.videoID).forEach(key => {\n            addSourceToLocal(self.$video, self.videoID[key], `video/${key}`);\n          });\n        }\n        let locStarted;\n        self.player.addEventListener('playing', e => {\n          if (!locStarted) {\n            self.fire('started', e);\n          }\n          locStarted = 1;\n        });\n        self.player.addEventListener('timeupdate', function (e) {\n          self.fire('timeupdate', e);\n\n          // check for end of video and play again or stop\n          if (self.options.endTime) {\n            if (self.options.endTime && this.currentTime >= self.options.endTime) {\n              if (self.options.loop) {\n                self.play(self.options.startTime);\n              } else {\n                self.pause();\n              }\n            }\n          }\n        });\n        self.player.addEventListener('play', e => {\n          self.fire('play', e);\n        });\n        self.player.addEventListener('pause', e => {\n          self.fire('pause', e);\n        });\n        self.player.addEventListener('ended', e => {\n          self.fire('ended', e);\n        });\n        self.player.addEventListener('loadedmetadata', function () {\n          // get video width and height\n          self.videoWidth = this.videoWidth || 1280;\n          self.videoHeight = this.videoHeight || 720;\n          self.fire('ready');\n\n          // autoplay\n          if (self.options.autoplay) {\n            self.play(self.options.startTime);\n          }\n        });\n        self.player.addEventListener('volumechange', e => {\n          self.getVolume(volume => {\n            self.options.volume = volume;\n          });\n          self.fire('volumechange', e);\n        });\n        self.player.addEventListener('error', e => {\n          self.fire('error', e);\n        });\n      }\n      callback(self.$video);\n    });\n  }\n  init() {\n    const self = this;\n    self.playerID = `VideoWorker-${self.ID}`;\n  }\n  loadAPI() {\n    const self = this;\n    if (YoutubeAPIadded && VimeoAPIadded) {\n      return;\n    }\n    let src = '';\n\n    // load Youtube API\n    if (self.type === 'youtube' && !YoutubeAPIadded) {\n      YoutubeAPIadded = 1;\n      src = 'https://www.youtube.com/iframe_api';\n    }\n\n    // load Vimeo API\n    if (self.type === 'vimeo' && !VimeoAPIadded) {\n      VimeoAPIadded = 1;\n\n      // Useful when Vimeo API added using RequireJS https://github.com/nk-o/video-worker/pull/7\n      if (typeof global$1.Vimeo !== 'undefined') {\n        return;\n      }\n      src = 'https://player.vimeo.com/api/player.js';\n    }\n    if (!src) {\n      return;\n    }\n\n    // add script in head section\n    let tag = document.createElement('script');\n    let head = document.getElementsByTagName('head')[0];\n    tag.src = src;\n    head.appendChild(tag);\n    head = null;\n    tag = null;\n  }\n  onAPIready(callback) {\n    const self = this;\n\n    // Youtube\n    if (self.type === 'youtube') {\n      // Listen for global YT player callback\n      if ((typeof global$1.YT === 'undefined' || global$1.YT.loaded === 0) && !loadingYoutubePlayer) {\n        // Prevents Ready event from being called twice\n        loadingYoutubePlayer = 1;\n\n        // Creates deferred so, other players know when to wait.\n        global$1.onYouTubeIframeAPIReady = function () {\n          global$1.onYouTubeIframeAPIReady = null;\n          loadingYoutubeDefer.resolve('done');\n          callback();\n        };\n      } else if (typeof global$1.YT === 'object' && global$1.YT.loaded === 1) {\n        callback();\n      } else {\n        loadingYoutubeDefer.done(() => {\n          callback();\n        });\n      }\n    }\n\n    // Vimeo\n    if (self.type === 'vimeo') {\n      if (typeof global$1.Vimeo === 'undefined' && !loadingVimeoPlayer) {\n        loadingVimeoPlayer = 1;\n        const vimeoInterval = setInterval(() => {\n          if (typeof global$1.Vimeo !== 'undefined') {\n            clearInterval(vimeoInterval);\n            loadingVimeoDefer.resolve('done');\n            callback();\n          }\n        }, 20);\n      } else if (typeof global$1.Vimeo !== 'undefined') {\n        callback();\n      } else {\n        loadingVimeoDefer.done(() => {\n          callback();\n        });\n      }\n    }\n\n    // Local\n    if (self.type === 'local') {\n      callback();\n    }\n  }\n}\n\nfunction jarallaxVideo$1(jarallax = global$2.jarallax) {\n  if (typeof jarallax === 'undefined') {\n    return;\n  }\n  const Jarallax = jarallax.constructor;\n\n  // append video after when block will be visible.\n  const defOnScroll = Jarallax.prototype.onScroll;\n  Jarallax.prototype.onScroll = function () {\n    const self = this;\n    defOnScroll.apply(self);\n    const isReady = !self.isVideoInserted && self.video && (!self.options.videoLazyLoading || self.isElementInViewport) && !self.options.disableVideo();\n    if (isReady) {\n      self.isVideoInserted = true;\n      self.video.getVideo(video => {\n        const $parent = video.parentNode;\n        self.css(video, {\n          position: self.image.position,\n          top: '0px',\n          left: '0px',\n          right: '0px',\n          bottom: '0px',\n          width: '100%',\n          height: '100%',\n          maxWidth: 'none',\n          maxHeight: 'none',\n          pointerEvents: 'none',\n          transformStyle: 'preserve-3d',\n          backfaceVisibility: 'hidden',\n          margin: 0,\n          zIndex: -1\n        });\n        self.$video = video;\n\n        // add Poster attribute to self-hosted video\n        if (self.video.type === 'local') {\n          if (self.image.src) {\n            self.$video.setAttribute('poster', self.image.src);\n          } else if (self.image.$item && self.image.$item.tagName === 'IMG' && self.image.$item.src) {\n            self.$video.setAttribute('poster', self.image.$item.src);\n          }\n        }\n\n        // add classname to video element\n        if (self.options.videoClass) {\n          self.$video.setAttribute('class', `${self.options.videoClass} ${self.options.videoClass}-${self.video.type}`);\n        }\n\n        // insert video tag\n        self.image.$container.appendChild(video);\n\n        // remove parent video element (created by VideoWorker)\n        $parent.parentNode.removeChild($parent);\n\n        // call onVideoInsert event\n        if (self.options.onVideoInsert) {\n          self.options.onVideoInsert.call(self);\n        }\n      });\n    }\n  };\n\n  // cover video\n  const defCoverImage = Jarallax.prototype.coverImage;\n  Jarallax.prototype.coverImage = function () {\n    const self = this;\n    const imageData = defCoverImage.apply(self);\n    const node = self.image.$item ? self.image.$item.nodeName : false;\n    if (imageData && self.video && node && (node === 'IFRAME' || node === 'VIDEO')) {\n      let h = imageData.image.height;\n      let w = h * self.image.width / self.image.height;\n      let ml = (imageData.container.width - w) / 2;\n      let mt = imageData.image.marginTop;\n      if (imageData.container.width > w) {\n        w = imageData.container.width;\n        h = w * self.image.height / self.image.width;\n        ml = 0;\n        mt += (imageData.image.height - h) / 2;\n      }\n\n      // add video height over than need to hide controls\n      if (node === 'IFRAME') {\n        h += 400;\n        mt -= 200;\n      }\n      self.css(self.$video, {\n        width: `${w}px`,\n        marginLeft: `${ml}px`,\n        height: `${h}px`,\n        marginTop: `${mt}px`\n      });\n    }\n    return imageData;\n  };\n\n  // init video\n  const defInitImg = Jarallax.prototype.initImg;\n  Jarallax.prototype.initImg = function () {\n    const self = this;\n    const defaultResult = defInitImg.apply(self);\n    if (!self.options.videoSrc) {\n      self.options.videoSrc = self.$item.getAttribute('data-jarallax-video') || null;\n    }\n    if (self.options.videoSrc) {\n      self.defaultInitImgResult = defaultResult;\n      return true;\n    }\n    return defaultResult;\n  };\n  const defCanInitParallax = Jarallax.prototype.canInitParallax;\n  Jarallax.prototype.canInitParallax = function () {\n    const self = this;\n    let defaultResult = defCanInitParallax.apply(self);\n    if (!self.options.videoSrc) {\n      return defaultResult;\n    }\n\n    // Init video api\n    const video = new VideoWorker(self.options.videoSrc, {\n      autoplay: true,\n      loop: self.options.videoLoop,\n      showControls: false,\n      accessibilityHidden: true,\n      startTime: self.options.videoStartTime || 0,\n      endTime: self.options.videoEndTime || 0,\n      mute: !self.options.videoVolume,\n      volume: self.options.videoVolume || 0\n    });\n\n    // call onVideoWorkerInit event\n    if (self.options.onVideoWorkerInit) {\n      self.options.onVideoWorkerInit.call(self, video);\n    }\n    function resetDefaultImage() {\n      if (self.image.$default_item) {\n        self.image.$item = self.image.$default_item;\n        self.image.$item.style.display = 'block';\n\n        // set image width and height\n        self.coverImage();\n        self.onScroll();\n      }\n    }\n    if (video.isValid()) {\n      // Force enable parallax.\n      // When the parallax disabled on mobile devices, we still need to display videos.\n      // https://github.com/nk-o/jarallax/issues/159\n      if (this.options.disableParallax()) {\n        defaultResult = true;\n        self.image.position = 'absolute';\n        self.options.type = 'scroll';\n        self.options.speed = 1;\n      }\n\n      // if parallax will not be inited, we can add thumbnail on background.\n      if (!defaultResult) {\n        if (!self.defaultInitImgResult) {\n          video.getImageURL(url => {\n            // save default user styles\n            const curStyle = self.$item.getAttribute('style');\n            if (curStyle) {\n              self.$item.setAttribute('data-jarallax-original-styles', curStyle);\n            }\n\n            // set new background\n            self.css(self.$item, {\n              'background-image': `url(\"${url}\")`,\n              'background-position': 'center',\n              'background-size': 'cover'\n            });\n          });\n        }\n\n        // init video\n      } else {\n        video.on('ready', () => {\n          if (self.options.videoPlayOnlyVisible) {\n            const oldOnScroll = self.onScroll;\n            self.onScroll = function () {\n              oldOnScroll.apply(self);\n              if (!self.videoError && (self.options.videoLoop || !self.options.videoLoop && !self.videoEnded)) {\n                if (self.isVisible()) {\n                  video.play();\n                } else {\n                  video.pause();\n                }\n              }\n            };\n          } else {\n            video.play();\n          }\n        });\n        video.on('started', () => {\n          self.image.$default_item = self.image.$item;\n          self.image.$item = self.$video;\n\n          // set video width and height\n          self.image.width = self.video.videoWidth || 1280;\n          self.image.height = self.video.videoHeight || 720;\n          self.coverImage();\n          self.onScroll();\n\n          // hide image\n          if (self.image.$default_item) {\n            self.image.$default_item.style.display = 'none';\n          }\n        });\n        video.on('ended', () => {\n          self.videoEnded = true;\n          if (!self.options.videoLoop) {\n            // show default image if Loop disabled.\n            resetDefaultImage();\n          }\n        });\n        video.on('error', () => {\n          self.videoError = true;\n\n          // show default image if video loading error.\n          resetDefaultImage();\n        });\n        self.video = video;\n\n        // set image if not exists\n        if (!self.defaultInitImgResult) {\n          // set empty image on self-hosted video if not defined\n          self.image.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';\n          if (video.type !== 'local') {\n            video.getImageURL(url => {\n              self.image.bgImage = `url(\"${url}\")`;\n              self.init();\n            });\n            return false;\n          }\n        }\n      }\n    }\n    return defaultResult;\n  };\n\n  // Destroy video parallax\n  const defDestroy = Jarallax.prototype.destroy;\n  Jarallax.prototype.destroy = function () {\n    const self = this;\n    if (self.image.$default_item) {\n      self.image.$item = self.image.$default_item;\n      delete self.image.$default_item;\n    }\n    defDestroy.apply(self);\n  };\n}\n\nfunction jarallaxElement$1(jarallax = global$2.jarallax) {\n  // eslint-disable-next-line no-console\n  console.warn(\"Jarallax Element extension is DEPRECATED, please, avoid using it. We recommend you look at something like `lax.js` library <https://github.com/alexfoxy/lax.js>. It is much more powerful and has a less code (in cases when you don't want to add parallax backgrounds).\");\n  if (typeof jarallax === 'undefined') {\n    return;\n  }\n  const Jarallax = jarallax.constructor;\n\n  // redefine default methods\n  ['initImg', 'canInitParallax', 'init', 'destroy', 'coverImage', 'isVisible', 'onScroll', 'onResize'].forEach(key => {\n    const def = Jarallax.prototype[key];\n    Jarallax.prototype[key] = function (...args) {\n      const self = this;\n      if (key === 'initImg' && self.$item.getAttribute('data-jarallax-element') !== null) {\n        self.options.type = 'element';\n        self.pureOptions.speed = self.$item.getAttribute('data-jarallax-element') || '100';\n      }\n      if (self.options.type !== 'element') {\n        return def.apply(self, args);\n      }\n      self.pureOptions.threshold = self.$item.getAttribute('data-threshold') || '';\n      switch (key) {\n        case 'init':\n          {\n            const speedArr = `${self.pureOptions.speed}`.split(' ');\n            self.options.speed = self.pureOptions.speed || 0;\n            self.options.speedY = speedArr[0] ? parseFloat(speedArr[0]) : 0;\n            self.options.speedX = speedArr[1] ? parseFloat(speedArr[1]) : 0;\n            const thresholdArr = self.pureOptions.threshold.split(' ');\n            self.options.thresholdY = thresholdArr[0] ? parseFloat(thresholdArr[0]) : null;\n            self.options.thresholdX = thresholdArr[1] ? parseFloat(thresholdArr[1]) : null;\n            def.apply(self, args);\n\n            // restore background image if available.\n            const originalStylesTag = self.$item.getAttribute('data-jarallax-original-styles');\n            if (originalStylesTag) {\n              self.$item.setAttribute('style', originalStylesTag);\n            }\n            return true;\n          }\n        case 'onResize':\n          {\n            const defTransform = self.css(self.$item, 'transform');\n            self.css(self.$item, {\n              transform: ''\n            });\n            const rect = self.$item.getBoundingClientRect();\n            self.itemData = {\n              width: rect.width,\n              height: rect.height,\n              y: rect.top + self.getWindowData().y,\n              x: rect.left\n            };\n            self.css(self.$item, {\n              transform: defTransform\n            });\n            break;\n          }\n        case 'onScroll':\n          {\n            const wnd = self.getWindowData();\n            const centerPercent = (wnd.y + wnd.height / 2 - self.itemData.y - self.itemData.height / 2) / (wnd.height / 2);\n            const moveY = centerPercent * self.options.speedY;\n            const moveX = centerPercent * self.options.speedX;\n            let my = moveY;\n            let mx = moveX;\n            if (self.options.thresholdY !== null && moveY > self.options.thresholdY) my = 0;\n            if (self.options.thresholdX !== null && moveX > self.options.thresholdX) mx = 0;\n            self.css(self.$item, {\n              transform: `translate3d(${mx}px,${my}px,0)`\n            });\n            break;\n          }\n        case 'initImg':\n        case 'isVisible':\n        case 'coverImage':\n          return true;\n        // no default\n      }\n\n      return def.apply(self, args);\n    };\n  });\n}\n\nconst jarallax = jarallax$1;\nconst jarallaxVideo = function jarallaxVideo() {\n  return jarallaxVideo$1(jarallax);\n};\nconst jarallaxElement = function jarallaxElement() {\n  return jarallaxElement$1(jarallax);\n};\n\nexport { jarallax, jarallaxElement, jarallaxVideo };\n//# sourceMappingURL=jarallax.esm.js.map\n","export default {\n  // Base parallax options.\n  type: 'scroll',\n  speed: 0.5,\n  containerClass: 'jarallax-container',\n  imgSrc: null,\n  imgElement: '.jarallax-img',\n  imgSize: 'cover',\n  imgPosition: '50% 50%',\n  imgRepeat: 'no-repeat',\n  keepImg: false,\n  elementInViewport: null,\n  zIndex: -100,\n  disableParallax: false,\n\n  // Callbacks.\n  onScroll: null,\n  onInit: null,\n  onDestroy: null,\n  onCoverImage: null,\n\n  // Video options.\n  videoClass: 'jarallax-video',\n  videoSrc: null,\n  videoStartTime: 0,\n  videoEndTime: 0,\n  videoVolume: 0,\n  videoLoop: true,\n  videoPlayOnlyVisible: true,\n  videoLazyLoading: true,\n  disableVideo: false,\n\n  // Video callbacks.\n  onVideoInsert: null,\n  onVideoWorkerInit: null,\n};\n","/* eslint-disable import/no-mutable-exports */\n/* eslint-disable no-restricted-globals */\nlet win;\n\nif (typeof window !== 'undefined') {\n  win = window;\n} else if (typeof global !== 'undefined') {\n  win = global;\n} else if (typeof self !== 'undefined') {\n  win = self;\n} else {\n  win = {};\n}\n\nexport default win;\n","import global from './global';\n\n/**\n * Add styles to element.\n *\n * @param {Element} el - element.\n * @param {String|Object} styles - styles list.\n *\n * @returns {Element}\n */\nexport default function css(el, styles) {\n  if (typeof styles === 'string') {\n    return global.getComputedStyle(el).getPropertyValue(styles);\n  }\n\n  Object.keys(styles).forEach((key) => {\n    el.style[key] = styles[key];\n  });\n  return el;\n}\n","/**\n * Extend like jQuery.extend\n *\n * @param {Object} out - output object.\n * @param {...any} args - additional objects to extend.\n *\n * @returns {Object}\n */\nexport default function extend(out, ...args) {\n  out = out || {};\n\n  Object.keys(args).forEach((i) => {\n    if (!args[i]) {\n      return;\n    }\n    Object.keys(args[i]).forEach((key) => {\n      out[key] = args[i][key];\n    });\n  });\n\n  return out;\n}\n","/**\n * Get all parents of the element.\n *\n * @param {Element} elem - DOM element.\n *\n * @returns {Array}\n */\nexport default function getParents(elem) {\n  const parents = [];\n\n  while (elem.parentElement !== null) {\n    elem = elem.parentElement;\n\n    if (elem.nodeType === 1) {\n      parents.push(elem);\n    }\n  }\n\n  return parents;\n}\n","/**\n * Document ready callback.\n * @param {Function} callback - callback will be fired once Document ready.\n */\nfunction ready(callback) {\n  if (document.readyState === 'complete' || document.readyState === 'interactive') {\n    // Already ready or interactive, execute callback\n    callback();\n  } else {\n    document.addEventListener('DOMContentLoaded', callback, {\n      capture: true,\n      once: true,\n      passive: true,\n    });\n  }\n}\n\nexport default ready;\n","import global from './global';\n\nconst { navigator } = global;\n\nconst mobileAgent = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(\n  navigator.userAgent\n);\n\nexport default function isMobile() {\n  return mobileAgent;\n}\n","import global from './global';\nimport domReady from './ready';\nimport isMobile from './isMobile';\n\nlet wndW;\nlet wndH;\nlet $deviceHelper;\n\n/**\n * The most popular mobile browsers changes height after page scroll and this generates image jumping.\n * We can fix it using this workaround with vh units.\n */\nfunction getDeviceHeight() {\n  if (!$deviceHelper && document.body) {\n    $deviceHelper = document.createElement('div');\n    $deviceHelper.style.cssText =\n      'position: fixed; top: -9999px; left: 0; height: 100vh; width: 0;';\n    document.body.appendChild($deviceHelper);\n  }\n\n  return (\n    ($deviceHelper ? $deviceHelper.clientHeight : 0) ||\n    global.innerHeight ||\n    document.documentElement.clientHeight\n  );\n}\n\nfunction updateWindowHeight() {\n  wndW = global.innerWidth || document.documentElement.clientWidth;\n\n  if (isMobile()) {\n    wndH = getDeviceHeight();\n  } else {\n    wndH = global.innerHeight || document.documentElement.clientHeight;\n  }\n}\n\nupdateWindowHeight();\nglobal.addEventListener('resize', updateWindowHeight);\nglobal.addEventListener('orientationchange', updateWindowHeight);\nglobal.addEventListener('load', updateWindowHeight);\ndomReady(() => {\n  updateWindowHeight({\n    type: 'dom-loaded',\n  });\n});\n\nexport default function getWindowSize() {\n  return {\n    width: wndW,\n    height: wndH,\n  };\n}\n","import global from './global';\nimport getWindowSize from './getWindowSize';\n\n// List with all jarallax instances\n// need to render all in one scroll/resize event.\nconst jarallaxList = [];\n\nfunction updateParallax() {\n  if (!jarallaxList.length) {\n    return;\n  }\n\n  const { width: wndW, height: wndH } = getWindowSize();\n\n  jarallaxList.forEach((data, k) => {\n    const { instance, oldData } = data;\n\n    if (!instance.isVisible()) {\n      return;\n    }\n\n    const clientRect = instance.$item.getBoundingClientRect();\n\n    const newData = {\n      width: clientRect.width,\n      height: clientRect.height,\n      top: clientRect.top,\n      bottom: clientRect.bottom,\n      wndW,\n      wndH,\n    };\n\n    const isResized =\n      !oldData ||\n      oldData.wndW !== newData.wndW ||\n      oldData.wndH !== newData.wndH ||\n      oldData.width !== newData.width ||\n      oldData.height !== newData.height;\n    const isScrolled =\n      isResized || !oldData || oldData.top !== newData.top || oldData.bottom !== newData.bottom;\n\n    jarallaxList[k].oldData = newData;\n\n    if (isResized) {\n      instance.onResize();\n    }\n    if (isScrolled) {\n      instance.onScroll();\n    }\n  });\n\n  global.requestAnimationFrame(updateParallax);\n}\n\nconst visibilityObserver = new global.IntersectionObserver(\n  (entries) => {\n    entries.forEach((entry) => {\n      entry.target.jarallax.isElementInViewport = entry.isIntersecting;\n    });\n  },\n  {\n    // We have to start parallax calculation before the block is in view\n    // to prevent possible parallax jumping.\n    rootMargin: '50px',\n  }\n);\n\nexport function addObserver(instance) {\n  jarallaxList.push({\n    instance,\n  });\n\n  if (jarallaxList.length === 1) {\n    global.requestAnimationFrame(updateParallax);\n  }\n\n  visibilityObserver.observe(instance.options.elementInViewport || instance.$item);\n}\n\nexport function removeObserver(instance) {\n  jarallaxList.forEach((data, key) => {\n    if (data.instance.instanceID === instance.instanceID) {\n      jarallaxList.splice(key, 1);\n    }\n  });\n\n  visibilityObserver.unobserve(instance.options.elementInViewport || instance.$item);\n}\n","/* eslint-disable class-methods-use-this */\nimport defaults from './defaults';\nimport global from './utils/global';\nimport css from './utils/css';\nimport extend from './utils/extend';\nimport getParents from './utils/getParents';\nimport getWindowSize from './utils/getWindowSize';\nimport { addObserver, removeObserver } from './utils/observer';\n\nconst { navigator } = global;\n\nlet instanceID = 0;\n\n// Jarallax class\nclass Jarallax {\n  constructor(item, userOptions) {\n    const self = this;\n\n    self.instanceID = instanceID;\n    instanceID += 1;\n\n    self.$item = item;\n\n    self.defaults = { ...defaults };\n\n    // prepare data-options\n    const dataOptions = self.$item.dataset || {};\n    const pureDataOptions = {};\n    Object.keys(dataOptions).forEach((key) => {\n      const lowerCaseOption = key.substr(0, 1).toLowerCase() + key.substr(1);\n      if (lowerCaseOption && typeof self.defaults[lowerCaseOption] !== 'undefined') {\n        pureDataOptions[lowerCaseOption] = dataOptions[key];\n      }\n    });\n\n    self.options = self.extend({}, self.defaults, pureDataOptions, userOptions);\n    self.pureOptions = self.extend({}, self.options);\n\n    // prepare 'true' and 'false' strings to boolean\n    Object.keys(self.options).forEach((key) => {\n      if (self.options[key] === 'true') {\n        self.options[key] = true;\n      } else if (self.options[key] === 'false') {\n        self.options[key] = false;\n      }\n    });\n\n    // fix speed option [-1.0, 2.0]\n    self.options.speed = Math.min(2, Math.max(-1, parseFloat(self.options.speed)));\n\n    // prepare disableParallax callback\n    if (typeof self.options.disableParallax === 'string') {\n      self.options.disableParallax = new RegExp(self.options.disableParallax);\n    }\n    if (self.options.disableParallax instanceof RegExp) {\n      const disableParallaxRegexp = self.options.disableParallax;\n      self.options.disableParallax = () => disableParallaxRegexp.test(navigator.userAgent);\n    }\n    if (typeof self.options.disableParallax !== 'function') {\n      self.options.disableParallax = () => false;\n    }\n\n    // prepare disableVideo callback\n    if (typeof self.options.disableVideo === 'string') {\n      self.options.disableVideo = new RegExp(self.options.disableVideo);\n    }\n    if (self.options.disableVideo instanceof RegExp) {\n      const disableVideoRegexp = self.options.disableVideo;\n      self.options.disableVideo = () => disableVideoRegexp.test(navigator.userAgent);\n    }\n    if (typeof self.options.disableVideo !== 'function') {\n      self.options.disableVideo = () => false;\n    }\n\n    // custom element to check if parallax in viewport\n    let elementInVP = self.options.elementInViewport;\n    // get first item from array\n    if (\n      elementInVP &&\n      typeof elementInVP === 'object' &&\n      typeof elementInVP.length !== 'undefined'\n    ) {\n      [elementInVP] = elementInVP;\n    }\n    // check if dom element\n    if (!(elementInVP instanceof Element)) {\n      elementInVP = null;\n    }\n    self.options.elementInViewport = elementInVP;\n\n    self.image = {\n      src: self.options.imgSrc || null,\n      $container: null,\n      useImgTag: false,\n\n      // 1. Position fixed is needed for the most of browsers because absolute position have glitches\n      // 2. On MacOS with smooth scroll there is a huge lags with absolute position - https://github.com/nk-o/jarallax/issues/75\n      // 3. Previously used 'absolute' for mobile devices. But we re-tested on iPhone 12 and 'fixed' position is working better, then 'absolute', so for now position is always 'fixed'\n      position: 'fixed',\n    };\n\n    if (self.initImg() && self.canInitParallax()) {\n      self.init();\n    }\n  }\n\n  css(el, styles) {\n    return css(el, styles);\n  }\n\n  extend(out, ...args) {\n    return extend(out, ...args);\n  }\n\n  // get window size and scroll position. Useful for extensions\n  getWindowData() {\n    const { width, height } = getWindowSize();\n\n    return {\n      width,\n      height,\n      y: document.documentElement.scrollTop,\n    };\n  }\n\n  // Jarallax functions\n  initImg() {\n    const self = this;\n\n    // find image element\n    let $imgElement = self.options.imgElement;\n    if ($imgElement && typeof $imgElement === 'string') {\n      $imgElement = self.$item.querySelector($imgElement);\n    }\n\n    // check if dom element\n    if (!($imgElement instanceof Element)) {\n      if (self.options.imgSrc) {\n        $imgElement = new Image();\n        $imgElement.src = self.options.imgSrc;\n      } else {\n        $imgElement = null;\n      }\n    }\n\n    if ($imgElement) {\n      if (self.options.keepImg) {\n        self.image.$item = $imgElement.cloneNode(true);\n      } else {\n        self.image.$item = $imgElement;\n        self.image.$itemParent = $imgElement.parentNode;\n      }\n      self.image.useImgTag = true;\n    }\n\n    // true if there is img tag\n    if (self.image.$item) {\n      return true;\n    }\n\n    // get image src\n    if (self.image.src === null) {\n      self.image.src =\n        'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';\n      self.image.bgImage = self.css(self.$item, 'background-image');\n    }\n    return !(!self.image.bgImage || self.image.bgImage === 'none');\n  }\n\n  canInitParallax() {\n    return !this.options.disableParallax();\n  }\n\n  init() {\n    const self = this;\n    const containerStyles = {\n      position: 'absolute',\n      top: 0,\n      left: 0,\n      width: '100%',\n      height: '100%',\n      overflow: 'hidden',\n    };\n    let imageStyles = {\n      pointerEvents: 'none',\n      transformStyle: 'preserve-3d',\n      backfaceVisibility: 'hidden',\n    };\n\n    if (!self.options.keepImg) {\n      // save default user styles\n      const curStyle = self.$item.getAttribute('style');\n      if (curStyle) {\n        self.$item.setAttribute('data-jarallax-original-styles', curStyle);\n      }\n      if (self.image.useImgTag) {\n        const curImgStyle = self.image.$item.getAttribute('style');\n        if (curImgStyle) {\n          self.image.$item.setAttribute('data-jarallax-original-styles', curImgStyle);\n        }\n      }\n    }\n\n    // set relative position and z-index to the parent\n    if (self.css(self.$item, 'position') === 'static') {\n      self.css(self.$item, {\n        position: 'relative',\n      });\n    }\n    if (self.css(self.$item, 'z-index') === 'auto') {\n      self.css(self.$item, {\n        zIndex: 0,\n      });\n    }\n\n    // container for parallax image\n    self.image.$container = document.createElement('div');\n    self.css(self.image.$container, containerStyles);\n    self.css(self.image.$container, {\n      'z-index': self.options.zIndex,\n    });\n\n    // it will remove some image overlapping\n    // overlapping occur due to an image position fixed inside absolute position element\n    // needed only when background in fixed position\n    if (this.image.position === 'fixed') {\n      self.css(self.image.$container, {\n        '-webkit-clip-path': 'polygon(0 0, 100% 0, 100% 100%, 0 100%)',\n        'clip-path': 'polygon(0 0, 100% 0, 100% 100%, 0 100%)',\n      });\n    }\n\n    // Add container unique ID.\n    self.image.$container.setAttribute('id', `jarallax-container-${self.instanceID}`);\n\n    // Add container class.\n    if (self.options.containerClass) {\n      self.image.$container.setAttribute('class', self.options.containerClass);\n    }\n\n    self.$item.appendChild(self.image.$container);\n\n    // use img tag\n    if (self.image.useImgTag) {\n      imageStyles = self.extend(\n        {\n          'object-fit': self.options.imgSize,\n          'object-position': self.options.imgPosition,\n          'max-width': 'none',\n        },\n        containerStyles,\n        imageStyles\n      );\n\n      // use div with background image\n    } else {\n      self.image.$item = document.createElement('div');\n      if (self.image.src) {\n        imageStyles = self.extend(\n          {\n            'background-position': self.options.imgPosition,\n            'background-size': self.options.imgSize,\n            'background-repeat': self.options.imgRepeat,\n            'background-image': self.image.bgImage || `url(\"${self.image.src}\")`,\n          },\n          containerStyles,\n          imageStyles\n        );\n      }\n    }\n\n    if (\n      self.options.type === 'opacity' ||\n      self.options.type === 'scale' ||\n      self.options.type === 'scale-opacity' ||\n      self.options.speed === 1\n    ) {\n      self.image.position = 'absolute';\n    }\n\n    // 1. Check if one of parents have transform style (without this check, scroll transform will be inverted if used parallax with position fixed)\n    //    discussion - https://github.com/nk-o/jarallax/issues/9\n    // 2. Check if parents have overflow scroll\n    if (self.image.position === 'fixed') {\n      const $parents = getParents(self.$item).filter((el) => {\n        const styles = global.getComputedStyle(el);\n        const parentTransform =\n          styles['-webkit-transform'] || styles['-moz-transform'] || styles.transform;\n        const overflowRegex = /(auto|scroll)/;\n\n        return (\n          (parentTransform && parentTransform !== 'none') ||\n          overflowRegex.test(styles.overflow + styles['overflow-y'] + styles['overflow-x'])\n        );\n      });\n\n      self.image.position = $parents.length ? 'absolute' : 'fixed';\n    }\n\n    // add position to parallax block\n    imageStyles.position = self.image.position;\n\n    // insert parallax image\n    self.css(self.image.$item, imageStyles);\n    self.image.$container.appendChild(self.image.$item);\n\n    // set initial position and size\n    self.onResize();\n    self.onScroll(true);\n\n    // call onInit event\n    if (self.options.onInit) {\n      self.options.onInit.call(self);\n    }\n\n    // remove default user background\n    if (self.css(self.$item, 'background-image') !== 'none') {\n      self.css(self.$item, {\n        'background-image': 'none',\n      });\n    }\n\n    addObserver(self);\n  }\n\n  destroy() {\n    const self = this;\n\n    removeObserver(self);\n\n    // return styles on container as before jarallax init\n    const originalStylesTag = self.$item.getAttribute('data-jarallax-original-styles');\n    self.$item.removeAttribute('data-jarallax-original-styles');\n    // null occurs if there is no style tag before jarallax init\n    if (!originalStylesTag) {\n      self.$item.removeAttribute('style');\n    } else {\n      self.$item.setAttribute('style', originalStylesTag);\n    }\n\n    if (self.image.useImgTag) {\n      // return styles on img tag as before jarallax init\n      const originalStylesImgTag = self.image.$item.getAttribute('data-jarallax-original-styles');\n      self.image.$item.removeAttribute('data-jarallax-original-styles');\n      // null occurs if there is no style tag before jarallax init\n      if (!originalStylesImgTag) {\n        self.image.$item.removeAttribute('style');\n      } else {\n        self.image.$item.setAttribute('style', originalStylesTag);\n      }\n\n      // move img tag to its default position\n      if (self.image.$itemParent) {\n        self.image.$itemParent.appendChild(self.image.$item);\n      }\n    }\n\n    // remove additional dom elements\n    if (self.image.$container) {\n      self.image.$container.parentNode.removeChild(self.image.$container);\n    }\n\n    // call onDestroy event\n    if (self.options.onDestroy) {\n      self.options.onDestroy.call(self);\n    }\n\n    // delete jarallax from item\n    delete self.$item.jarallax;\n  }\n\n  coverImage() {\n    const self = this;\n\n    const { height: wndH } = getWindowSize();\n    const rect = self.image.$container.getBoundingClientRect();\n    const contH = rect.height;\n    const { speed } = self.options;\n    const isScroll = self.options.type === 'scroll' || self.options.type === 'scroll-opacity';\n    let scrollDist = 0;\n    let resultH = contH;\n    let resultMT = 0;\n\n    // scroll parallax\n    if (isScroll) {\n      // scroll distance and height for image\n      if (speed < 0) {\n        scrollDist = speed * Math.max(contH, wndH);\n\n        if (wndH < contH) {\n          scrollDist -= speed * (contH - wndH);\n        }\n      } else {\n        scrollDist = speed * (contH + wndH);\n      }\n\n      // size for scroll parallax\n      if (speed > 1) {\n        resultH = Math.abs(scrollDist - wndH);\n      } else if (speed < 0) {\n        resultH = scrollDist / speed + Math.abs(scrollDist);\n      } else {\n        resultH += (wndH - contH) * (1 - speed);\n      }\n\n      scrollDist /= 2;\n    }\n\n    // store scroll distance\n    self.parallaxScrollDistance = scrollDist;\n\n    // vertical center\n    if (isScroll) {\n      resultMT = (wndH - resultH) / 2;\n    } else {\n      resultMT = (contH - resultH) / 2;\n    }\n\n    // apply result to item\n    self.css(self.image.$item, {\n      height: `${resultH}px`,\n      marginTop: `${resultMT}px`,\n      left: self.image.position === 'fixed' ? `${rect.left}px` : '0',\n      width: `${rect.width}px`,\n    });\n\n    // call onCoverImage event\n    if (self.options.onCoverImage) {\n      self.options.onCoverImage.call(self);\n    }\n\n    // return some useful data. Used in the video cover function\n    return {\n      image: {\n        height: resultH,\n        marginTop: resultMT,\n      },\n      container: rect,\n    };\n  }\n\n  isVisible() {\n    return this.isElementInViewport || false;\n  }\n\n  onScroll(force) {\n    const self = this;\n\n    // stop calculations if item is not in viewport\n    if (!force && !self.isVisible()) {\n      return;\n    }\n\n    const { height: wndH } = getWindowSize();\n    const rect = self.$item.getBoundingClientRect();\n    const contT = rect.top;\n    const contH = rect.height;\n    const styles = {};\n\n    // calculate parallax helping variables\n    const beforeTop = Math.max(0, contT);\n    const beforeTopEnd = Math.max(0, contH + contT);\n    const afterTop = Math.max(0, -contT);\n    const beforeBottom = Math.max(0, contT + contH - wndH);\n    const beforeBottomEnd = Math.max(0, contH - (contT + contH - wndH));\n    const afterBottom = Math.max(0, -contT + wndH - contH);\n    const fromViewportCenter = 1 - 2 * ((wndH - contT) / (wndH + contH));\n\n    // calculate on how percent of section is visible\n    let visiblePercent = 1;\n    if (contH < wndH) {\n      visiblePercent = 1 - (afterTop || beforeBottom) / contH;\n    } else if (beforeTopEnd <= wndH) {\n      visiblePercent = beforeTopEnd / wndH;\n    } else if (beforeBottomEnd <= wndH) {\n      visiblePercent = beforeBottomEnd / wndH;\n    }\n\n    // opacity\n    if (\n      self.options.type === 'opacity' ||\n      self.options.type === 'scale-opacity' ||\n      self.options.type === 'scroll-opacity'\n    ) {\n      styles.transform = 'translate3d(0,0,0)';\n      styles.opacity = visiblePercent;\n    }\n\n    // scale\n    if (self.options.type === 'scale' || self.options.type === 'scale-opacity') {\n      let scale = 1;\n      if (self.options.speed < 0) {\n        scale -= self.options.speed * visiblePercent;\n      } else {\n        scale += self.options.speed * (1 - visiblePercent);\n      }\n      styles.transform = `scale(${scale}) translate3d(0,0,0)`;\n    }\n\n    // scroll\n    if (self.options.type === 'scroll' || self.options.type === 'scroll-opacity') {\n      let positionY = self.parallaxScrollDistance * fromViewportCenter;\n\n      // fix if parallax block in absolute position\n      if (self.image.position === 'absolute') {\n        positionY -= contT;\n      }\n\n      styles.transform = `translate3d(0,${positionY}px,0)`;\n    }\n\n    self.css(self.image.$item, styles);\n\n    // call onScroll event\n    if (self.options.onScroll) {\n      self.options.onScroll.call(self, {\n        section: rect,\n\n        beforeTop,\n        beforeTopEnd,\n        afterTop,\n        beforeBottom,\n        beforeBottomEnd,\n        afterBottom,\n\n        visiblePercent,\n        fromViewportCenter,\n      });\n    }\n  }\n\n  onResize() {\n    this.coverImage();\n  }\n}\n\n// global definition\nconst jarallax = function (items, options, ...args) {\n  // check for dom element\n  // thanks: http://stackoverflow.com/questions/384286/javascript-isdom-how-do-you-check-if-a-javascript-object-is-a-dom-object\n  if (\n    typeof HTMLElement === 'object'\n      ? items instanceof HTMLElement\n      : items &&\n        typeof items === 'object' &&\n        items !== null &&\n        items.nodeType === 1 &&\n        typeof items.nodeName === 'string'\n  ) {\n    items = [items];\n  }\n\n  const len = items.length;\n  let k = 0;\n  let ret;\n\n  for (k; k < len; k += 1) {\n    if (typeof options === 'object' || typeof options === 'undefined') {\n      if (!items[k].jarallax) {\n        items[k].jarallax = new Jarallax(items[k], options);\n      }\n    } else if (items[k].jarallax) {\n      // eslint-disable-next-line prefer-spread\n      ret = items[k].jarallax[options].apply(items[k].jarallax, args);\n    }\n    if (typeof ret !== 'undefined') {\n      return ret;\n    }\n  }\n\n  return items;\n};\njarallax.constructor = Jarallax;\n\nexport default jarallax;\n","/*!\n * Video Worker v2.1.5 (https://github.com/nk-o/video-worker)\n * Copyright 2022 nK <https://nkdev.info>\n * Licensed under MIT (https://github.com/nk-o/video-worker/blob/master/LICENSE)\n */\n\n/* eslint-disable import/no-mutable-exports */\n/* eslint-disable no-restricted-globals */\nlet win;\nif (typeof window !== 'undefined') {\n  win = window;\n} else if (typeof global !== 'undefined') {\n  win = global;\n} else if (typeof self !== 'undefined') {\n  win = self;\n} else {\n  win = {};\n}\nvar global$1 = win;\n\n// Deferred\n// thanks http://stackoverflow.com/questions/18096715/implement-deferred-object-without-using-jquery\nfunction Deferred() {\n  this.doneCallbacks = [];\n  this.failCallbacks = [];\n}\nDeferred.prototype = {\n  execute(list, args) {\n    let i = list.length;\n    // eslint-disable-next-line no-param-reassign\n    args = Array.prototype.slice.call(args);\n    while (i) {\n      i -= 1;\n      list[i].apply(null, args);\n    }\n  },\n  resolve(...args) {\n    this.execute(this.doneCallbacks, args);\n  },\n  reject(...args) {\n    this.execute(this.failCallbacks, args);\n  },\n  done(callback) {\n    this.doneCallbacks.push(callback);\n  },\n  fail(callback) {\n    this.failCallbacks.push(callback);\n  }\n};\n\nvar defaults = {\n  autoplay: false,\n  loop: false,\n  mute: false,\n  volume: 100,\n  showControls: true,\n  accessibilityHidden: false,\n  // start / end video time in seconds\n  startTime: 0,\n  endTime: 0\n};\n\n/**\n * Extend like jQuery.extend\n *\n * @param {Object} out - output object.\n * @param {...any} args - additional objects to extend.\n *\n * @returns {Object}\n */\nfunction extend(out, ...args) {\n  out = out || {};\n  Object.keys(args).forEach(i => {\n    if (!args[i]) {\n      return;\n    }\n    Object.keys(args[i]).forEach(key => {\n      out[key] = args[i][key];\n    });\n  });\n  return out;\n}\n\nlet ID = 0;\nlet YoutubeAPIadded = 0;\nlet VimeoAPIadded = 0;\nlet loadingYoutubePlayer = 0;\nlet loadingVimeoPlayer = 0;\nconst loadingYoutubeDefer = /*#__PURE__*/new Deferred();\nconst loadingVimeoDefer = /*#__PURE__*/new Deferred();\nclass VideoWorker {\n  constructor(url, options) {\n    const self = this;\n    self.url = url;\n    self.options_default = {\n      ...defaults\n    };\n    self.options = extend({}, self.options_default, options);\n\n    // check URL\n    self.videoID = self.parseURL(url);\n\n    // init\n    if (self.videoID) {\n      self.ID = ID;\n      ID += 1;\n      self.loadAPI();\n      self.init();\n    }\n  }\n  parseURL(url) {\n    // parse youtube ID\n    function getYoutubeID(ytUrl) {\n      // eslint-disable-next-line no-useless-escape\n      const regExp = /.*(?:youtu.be\\/|v\\/|u\\/\\w\\/|embed\\/|shorts\\/|watch\\?v=)([^#\\&\\?]*).*/;\n      const match = ytUrl.match(regExp);\n      return match && match[1].length === 11 ? match[1] : false;\n    }\n\n    // parse vimeo ID\n    function getVimeoID(vmUrl) {\n      // eslint-disable-next-line no-useless-escape\n      const regExp = /https?:\\/\\/(?:www\\.|player\\.)?vimeo.com\\/(?:channels\\/(?:\\w+\\/)?|groups\\/([^/]*)\\/videos\\/|album\\/(\\d+)\\/video\\/|video\\/|)(\\d+)(?:$|\\/|\\?)/;\n      const match = vmUrl.match(regExp);\n      return match && match[3] ? match[3] : false;\n    }\n\n    // parse local string\n    function getLocalVideos(locUrl) {\n      // eslint-disable-next-line no-useless-escape\n      const videoFormats = locUrl.split(/,(?=mp4\\:|webm\\:|ogv\\:|ogg\\:)/);\n      const result = {};\n      let ready = 0;\n      videoFormats.forEach(val => {\n        // eslint-disable-next-line no-useless-escape\n        const match = val.match(/^(mp4|webm|ogv|ogg)\\:(.*)/);\n        if (match && match[1] && match[2]) {\n          // eslint-disable-next-line prefer-destructuring\n          result[match[1] === 'ogv' ? 'ogg' : match[1]] = match[2];\n          ready = 1;\n        }\n      });\n      return ready ? result : false;\n    }\n    const Youtube = getYoutubeID(url);\n    const Vimeo = getVimeoID(url);\n    const Local = getLocalVideos(url);\n    if (Youtube) {\n      this.type = 'youtube';\n      return Youtube;\n    }\n    if (Vimeo) {\n      this.type = 'vimeo';\n      return Vimeo;\n    }\n    if (Local) {\n      this.type = 'local';\n      return Local;\n    }\n    return false;\n  }\n  isValid() {\n    return !!this.videoID;\n  }\n\n  // events\n  on(name, callback) {\n    this.userEventsList = this.userEventsList || [];\n\n    // add new callback in events list\n    (this.userEventsList[name] || (this.userEventsList[name] = [])).push(callback);\n  }\n  off(name, callback) {\n    if (!this.userEventsList || !this.userEventsList[name]) {\n      return;\n    }\n    if (!callback) {\n      delete this.userEventsList[name];\n    } else {\n      this.userEventsList[name].forEach((val, key) => {\n        if (val === callback) {\n          this.userEventsList[name][key] = false;\n        }\n      });\n    }\n  }\n  fire(name, ...args) {\n    if (this.userEventsList && typeof this.userEventsList[name] !== 'undefined') {\n      this.userEventsList[name].forEach(val => {\n        // call with all arguments\n        if (val) {\n          val.apply(this, args);\n        }\n      });\n    }\n  }\n  play(start) {\n    const self = this;\n    if (!self.player) {\n      return;\n    }\n    if (self.type === 'youtube' && self.player.playVideo) {\n      if (typeof start !== 'undefined') {\n        self.player.seekTo(start || 0);\n      }\n      if (global$1.YT.PlayerState.PLAYING !== self.player.getPlayerState()) {\n        self.player.playVideo();\n      }\n    }\n    if (self.type === 'vimeo') {\n      if (typeof start !== 'undefined') {\n        self.player.setCurrentTime(start);\n      }\n      self.player.getPaused().then(paused => {\n        if (paused) {\n          self.player.play();\n        }\n      });\n    }\n    if (self.type === 'local') {\n      if (typeof start !== 'undefined') {\n        self.player.currentTime = start;\n      }\n      if (self.player.paused) {\n        self.player.play();\n      }\n    }\n  }\n  pause() {\n    const self = this;\n    if (!self.player) {\n      return;\n    }\n    if (self.type === 'youtube' && self.player.pauseVideo) {\n      if (global$1.YT.PlayerState.PLAYING === self.player.getPlayerState()) {\n        self.player.pauseVideo();\n      }\n    }\n    if (self.type === 'vimeo') {\n      self.player.getPaused().then(paused => {\n        if (!paused) {\n          self.player.pause();\n        }\n      });\n    }\n    if (self.type === 'local') {\n      if (!self.player.paused) {\n        self.player.pause();\n      }\n    }\n  }\n  mute() {\n    const self = this;\n    if (!self.player) {\n      return;\n    }\n    if (self.type === 'youtube' && self.player.mute) {\n      self.player.mute();\n    }\n    if (self.type === 'vimeo' && self.player.setVolume) {\n      self.setVolume(0);\n    }\n    if (self.type === 'local') {\n      self.$video.muted = true;\n    }\n  }\n  unmute() {\n    const self = this;\n    if (!self.player) {\n      return;\n    }\n    if (self.type === 'youtube' && self.player.mute) {\n      self.player.unMute();\n    }\n    if (self.type === 'vimeo' && self.player.setVolume) {\n      // In case the default volume is 0, we have to set 100 when unmute.\n      self.setVolume(self.options.volume || 100);\n    }\n    if (self.type === 'local') {\n      self.$video.muted = false;\n    }\n  }\n  setVolume(volume = false) {\n    const self = this;\n    if (!self.player || typeof volume !== 'number') {\n      return;\n    }\n    if (self.type === 'youtube' && self.player.setVolume) {\n      self.player.setVolume(volume);\n    }\n    if (self.type === 'vimeo' && self.player.setVolume) {\n      self.player.setVolume(volume / 100);\n    }\n    if (self.type === 'local') {\n      self.$video.volume = volume / 100;\n    }\n  }\n  getVolume(callback) {\n    const self = this;\n    if (!self.player) {\n      callback(false);\n      return;\n    }\n    if (self.type === 'youtube' && self.player.getVolume) {\n      callback(self.player.getVolume());\n    }\n    if (self.type === 'vimeo' && self.player.getVolume) {\n      self.player.getVolume().then(volume => {\n        callback(volume * 100);\n      });\n    }\n    if (self.type === 'local') {\n      callback(self.$video.volume * 100);\n    }\n  }\n  getMuted(callback) {\n    const self = this;\n    if (!self.player) {\n      callback(null);\n      return;\n    }\n    if (self.type === 'youtube' && self.player.isMuted) {\n      callback(self.player.isMuted());\n    }\n    if (self.type === 'vimeo' && self.player.getVolume) {\n      self.player.getVolume().then(volume => {\n        callback(!!volume);\n      });\n    }\n    if (self.type === 'local') {\n      callback(self.$video.muted);\n    }\n  }\n  getImageURL(callback) {\n    const self = this;\n    if (self.videoImage) {\n      callback(self.videoImage);\n      return;\n    }\n    if (self.type === 'youtube') {\n      const availableSizes = ['maxresdefault', 'sddefault', 'hqdefault', '0'];\n      let step = 0;\n      const tempImg = new Image();\n      tempImg.onload = function () {\n        // if no thumbnail, youtube add their own image with width = 120px\n        if ((this.naturalWidth || this.width) !== 120 || step === availableSizes.length - 1) {\n          // ok\n          self.videoImage = `https://img.youtube.com/vi/${self.videoID}/${availableSizes[step]}.jpg`;\n          callback(self.videoImage);\n        } else {\n          // try another size\n          step += 1;\n          this.src = `https://img.youtube.com/vi/${self.videoID}/${availableSizes[step]}.jpg`;\n        }\n      };\n      tempImg.src = `https://img.youtube.com/vi/${self.videoID}/${availableSizes[step]}.jpg`;\n    }\n    if (self.type === 'vimeo') {\n      // We should provide width to get HQ thumbnail URL.\n      let width = global$1.innerWidth || 1920;\n      if (global$1.devicePixelRatio) {\n        width *= global$1.devicePixelRatio;\n      }\n      width = Math.min(width, 1920);\n      let request = new XMLHttpRequest();\n      // https://vimeo.com/api/oembed.json?url=https://vimeo.com/235212527\n      request.open('GET', `https://vimeo.com/api/oembed.json?url=${self.url}&width=${width}`, true);\n      request.onreadystatechange = function () {\n        if (this.readyState === 4) {\n          if (this.status >= 200 && this.status < 400) {\n            // Success!\n            const response = JSON.parse(this.responseText);\n            if (response.thumbnail_url) {\n              self.videoImage = response.thumbnail_url;\n              callback(self.videoImage);\n            }\n          }\n        }\n      };\n      request.send();\n      request = null;\n    }\n  }\n\n  // fallback to the old version.\n  getIframe(callback) {\n    this.getVideo(callback);\n  }\n  getVideo(callback) {\n    const self = this;\n\n    // return generated video block\n    if (self.$video) {\n      callback(self.$video);\n      return;\n    }\n\n    // generate new video block\n    self.onAPIready(() => {\n      let hiddenDiv;\n      if (!self.$video) {\n        hiddenDiv = document.createElement('div');\n        hiddenDiv.style.display = 'none';\n      }\n\n      // Youtube\n      if (self.type === 'youtube') {\n        self.playerOptions = {\n          // GDPR Compliance.\n          host: 'https://www.youtube-nocookie.com',\n          videoId: self.videoID,\n          playerVars: {\n            autohide: 1,\n            rel: 0,\n            autoplay: 0,\n            // autoplay enable on mobile devices\n            playsinline: 1\n          }\n        };\n\n        // hide controls\n        if (!self.options.showControls) {\n          self.playerOptions.playerVars.iv_load_policy = 3;\n          self.playerOptions.playerVars.modestbranding = 1;\n          self.playerOptions.playerVars.controls = 0;\n          self.playerOptions.playerVars.showinfo = 0;\n          self.playerOptions.playerVars.disablekb = 1;\n        }\n\n        // events\n        let ytStarted;\n        let ytProgressInterval;\n        self.playerOptions.events = {\n          onReady(e) {\n            // mute\n            if (self.options.mute) {\n              e.target.mute();\n            } else if (typeof self.options.volume === 'number') {\n              e.target.setVolume(self.options.volume);\n            }\n\n            // autoplay\n            if (self.options.autoplay) {\n              self.play(self.options.startTime);\n            }\n            self.fire('ready', e);\n\n            // For seamless loops, set the endTime to 0.1 seconds less than the video's duration\n            // https://github.com/nk-o/video-worker/issues/2\n            if (self.options.loop && !self.options.endTime) {\n              const secondsOffset = 0.1;\n              self.options.endTime = self.player.getDuration() - secondsOffset;\n            }\n\n            // volumechange\n            setInterval(() => {\n              self.getVolume(volume => {\n                if (self.options.volume !== volume) {\n                  self.options.volume = volume;\n                  self.fire('volumechange', e);\n                }\n              });\n            }, 150);\n          },\n          onStateChange(e) {\n            // loop\n            if (self.options.loop && e.data === global$1.YT.PlayerState.ENDED) {\n              self.play(self.options.startTime);\n            }\n            if (!ytStarted && e.data === global$1.YT.PlayerState.PLAYING) {\n              ytStarted = 1;\n              self.fire('started', e);\n            }\n            if (e.data === global$1.YT.PlayerState.PLAYING) {\n              self.fire('play', e);\n            }\n            if (e.data === global$1.YT.PlayerState.PAUSED) {\n              self.fire('pause', e);\n            }\n            if (e.data === global$1.YT.PlayerState.ENDED) {\n              self.fire('ended', e);\n            }\n\n            // progress check\n            if (e.data === global$1.YT.PlayerState.PLAYING) {\n              ytProgressInterval = setInterval(() => {\n                self.fire('timeupdate', e);\n\n                // check for end of video and play again or stop\n                if (self.options.endTime && self.player.getCurrentTime() >= self.options.endTime) {\n                  if (self.options.loop) {\n                    self.play(self.options.startTime);\n                  } else {\n                    self.pause();\n                  }\n                }\n              }, 150);\n            } else {\n              clearInterval(ytProgressInterval);\n            }\n          },\n          onError(e) {\n            self.fire('error', e);\n          }\n        };\n        const firstInit = !self.$video;\n        if (firstInit) {\n          const div = document.createElement('div');\n          div.setAttribute('id', self.playerID);\n          hiddenDiv.appendChild(div);\n          document.body.appendChild(hiddenDiv);\n        }\n        self.player = self.player || new global$1.YT.Player(self.playerID, self.playerOptions);\n        if (firstInit) {\n          self.$video = document.getElementById(self.playerID);\n\n          // add accessibility attributes\n          if (self.options.accessibilityHidden) {\n            self.$video.setAttribute('tabindex', '-1');\n            self.$video.setAttribute('aria-hidden', 'true');\n          }\n\n          // get video width and height\n          self.videoWidth = parseInt(self.$video.getAttribute('width'), 10) || 1280;\n          self.videoHeight = parseInt(self.$video.getAttribute('height'), 10) || 720;\n        }\n      }\n\n      // Vimeo\n      if (self.type === 'vimeo') {\n        self.playerOptions = {\n          // GDPR Compliance.\n          dnt: 1,\n          id: self.videoID,\n          autopause: 0,\n          transparent: 0,\n          autoplay: self.options.autoplay ? 1 : 0,\n          loop: self.options.loop ? 1 : 0,\n          muted: self.options.mute || self.options.volume === 0 ? 1 : 0\n        };\n\n        // hide controls\n        if (!self.options.showControls) {\n          self.playerOptions.controls = 0;\n        }\n\n        // enable background option\n        if (!self.options.showControls && self.options.loop && self.options.autoplay) {\n          self.playerOptions.background = 1;\n        }\n        if (!self.$video) {\n          let playerOptionsString = '';\n          Object.keys(self.playerOptions).forEach(key => {\n            if (playerOptionsString !== '') {\n              playerOptionsString += '&';\n            }\n            playerOptionsString += `${key}=${encodeURIComponent(self.playerOptions[key])}`;\n          });\n\n          // we need to create iframe manually because when we create it using API\n          // js events won't triggers after iframe moved to another place\n          self.$video = document.createElement('iframe');\n          self.$video.setAttribute('id', self.playerID);\n          self.$video.setAttribute('src', `https://player.vimeo.com/video/${self.videoID}?${playerOptionsString}`);\n          self.$video.setAttribute('frameborder', '0');\n          self.$video.setAttribute('mozallowfullscreen', '');\n          self.$video.setAttribute('allowfullscreen', '');\n          self.$video.setAttribute('title', 'Vimeo video player');\n\n          // add accessibility attributes\n          if (self.options.accessibilityHidden) {\n            self.$video.setAttribute('tabindex', '-1');\n            self.$video.setAttribute('aria-hidden', 'true');\n          }\n          hiddenDiv.appendChild(self.$video);\n          document.body.appendChild(hiddenDiv);\n        }\n        self.player = self.player || new global$1.Vimeo.Player(self.$video, self.playerOptions);\n\n        // Since Vimeo removed the `volume` parameter, we have to set it manually.\n        if (!self.options.mute && typeof self.options.volume === 'number') {\n          self.setVolume(self.options.volume);\n        }\n\n        // set current time for autoplay\n        if (self.options.startTime && self.options.autoplay) {\n          self.player.setCurrentTime(self.options.startTime);\n        }\n\n        // get video width and height\n        self.player.getVideoWidth().then(width => {\n          self.videoWidth = width || 1280;\n        });\n        self.player.getVideoHeight().then(height => {\n          self.videoHeight = height || 720;\n        });\n\n        // events\n        let vmStarted;\n        self.player.on('timeupdate', e => {\n          if (!vmStarted) {\n            self.fire('started', e);\n            vmStarted = 1;\n          }\n          self.fire('timeupdate', e);\n\n          // check for end of video and play again or stop\n          if (self.options.endTime) {\n            if (self.options.endTime && e.seconds >= self.options.endTime) {\n              if (self.options.loop) {\n                self.play(self.options.startTime);\n              } else {\n                self.pause();\n              }\n            }\n          }\n        });\n        self.player.on('play', e => {\n          self.fire('play', e);\n\n          // check for the start time and start with it\n          if (self.options.startTime && e.seconds === 0) {\n            self.play(self.options.startTime);\n          }\n        });\n        self.player.on('pause', e => {\n          self.fire('pause', e);\n        });\n        self.player.on('ended', e => {\n          self.fire('ended', e);\n        });\n        self.player.on('loaded', e => {\n          self.fire('ready', e);\n        });\n        self.player.on('volumechange', e => {\n          self.getVolume(volume => {\n            self.options.volume = volume;\n          });\n          self.fire('volumechange', e);\n        });\n        self.player.on('error', e => {\n          self.fire('error', e);\n        });\n      }\n\n      // Local\n      function addSourceToLocal(element, src, type) {\n        const source = document.createElement('source');\n        source.src = src;\n        source.type = type;\n        element.appendChild(source);\n      }\n      if (self.type === 'local') {\n        if (!self.$video) {\n          self.$video = document.createElement('video');\n          self.player = self.$video;\n\n          // show controls\n          if (self.options.showControls) {\n            self.$video.controls = true;\n          }\n\n          // set volume\n          if (typeof self.options.volume === 'number') {\n            self.setVolume(self.options.volume);\n          }\n\n          // mute (it is required to mute after the volume set)\n          if (self.options.mute) {\n            self.mute();\n          }\n\n          // loop\n          if (self.options.loop) {\n            self.$video.loop = true;\n          }\n\n          // autoplay enable on mobile devices\n          self.$video.setAttribute('playsinline', '');\n          self.$video.setAttribute('webkit-playsinline', '');\n\n          // add accessibility attributes\n          if (self.options.accessibilityHidden) {\n            self.$video.setAttribute('tabindex', '-1');\n            self.$video.setAttribute('aria-hidden', 'true');\n          }\n          self.$video.setAttribute('id', self.playerID);\n          hiddenDiv.appendChild(self.$video);\n          document.body.appendChild(hiddenDiv);\n          Object.keys(self.videoID).forEach(key => {\n            addSourceToLocal(self.$video, self.videoID[key], `video/${key}`);\n          });\n        }\n        let locStarted;\n        self.player.addEventListener('playing', e => {\n          if (!locStarted) {\n            self.fire('started', e);\n          }\n          locStarted = 1;\n        });\n        self.player.addEventListener('timeupdate', function (e) {\n          self.fire('timeupdate', e);\n\n          // check for end of video and play again or stop\n          if (self.options.endTime) {\n            if (self.options.endTime && this.currentTime >= self.options.endTime) {\n              if (self.options.loop) {\n                self.play(self.options.startTime);\n              } else {\n                self.pause();\n              }\n            }\n          }\n        });\n        self.player.addEventListener('play', e => {\n          self.fire('play', e);\n        });\n        self.player.addEventListener('pause', e => {\n          self.fire('pause', e);\n        });\n        self.player.addEventListener('ended', e => {\n          self.fire('ended', e);\n        });\n        self.player.addEventListener('loadedmetadata', function () {\n          // get video width and height\n          self.videoWidth = this.videoWidth || 1280;\n          self.videoHeight = this.videoHeight || 720;\n          self.fire('ready');\n\n          // autoplay\n          if (self.options.autoplay) {\n            self.play(self.options.startTime);\n          }\n        });\n        self.player.addEventListener('volumechange', e => {\n          self.getVolume(volume => {\n            self.options.volume = volume;\n          });\n          self.fire('volumechange', e);\n        });\n        self.player.addEventListener('error', e => {\n          self.fire('error', e);\n        });\n      }\n      callback(self.$video);\n    });\n  }\n  init() {\n    const self = this;\n    self.playerID = `VideoWorker-${self.ID}`;\n  }\n  loadAPI() {\n    const self = this;\n    if (YoutubeAPIadded && VimeoAPIadded) {\n      return;\n    }\n    let src = '';\n\n    // load Youtube API\n    if (self.type === 'youtube' && !YoutubeAPIadded) {\n      YoutubeAPIadded = 1;\n      src = 'https://www.youtube.com/iframe_api';\n    }\n\n    // load Vimeo API\n    if (self.type === 'vimeo' && !VimeoAPIadded) {\n      VimeoAPIadded = 1;\n\n      // Useful when Vimeo API added using RequireJS https://github.com/nk-o/video-worker/pull/7\n      if (typeof global$1.Vimeo !== 'undefined') {\n        return;\n      }\n      src = 'https://player.vimeo.com/api/player.js';\n    }\n    if (!src) {\n      return;\n    }\n\n    // add script in head section\n    let tag = document.createElement('script');\n    let head = document.getElementsByTagName('head')[0];\n    tag.src = src;\n    head.appendChild(tag);\n    head = null;\n    tag = null;\n  }\n  onAPIready(callback) {\n    const self = this;\n\n    // Youtube\n    if (self.type === 'youtube') {\n      // Listen for global YT player callback\n      if ((typeof global$1.YT === 'undefined' || global$1.YT.loaded === 0) && !loadingYoutubePlayer) {\n        // Prevents Ready event from being called twice\n        loadingYoutubePlayer = 1;\n\n        // Creates deferred so, other players know when to wait.\n        global$1.onYouTubeIframeAPIReady = function () {\n          global$1.onYouTubeIframeAPIReady = null;\n          loadingYoutubeDefer.resolve('done');\n          callback();\n        };\n      } else if (typeof global$1.YT === 'object' && global$1.YT.loaded === 1) {\n        callback();\n      } else {\n        loadingYoutubeDefer.done(() => {\n          callback();\n        });\n      }\n    }\n\n    // Vimeo\n    if (self.type === 'vimeo') {\n      if (typeof global$1.Vimeo === 'undefined' && !loadingVimeoPlayer) {\n        loadingVimeoPlayer = 1;\n        const vimeoInterval = setInterval(() => {\n          if (typeof global$1.Vimeo !== 'undefined') {\n            clearInterval(vimeoInterval);\n            loadingVimeoDefer.resolve('done');\n            callback();\n          }\n        }, 20);\n      } else if (typeof global$1.Vimeo !== 'undefined') {\n        callback();\n      } else {\n        loadingVimeoDefer.done(() => {\n          callback();\n        });\n      }\n    }\n\n    // Local\n    if (self.type === 'local') {\n      callback();\n    }\n  }\n}\n\nexport { VideoWorker as default };\n//# sourceMappingURL=video-worker.esm.js.map\n","import VideoWorker from 'video-worker';\n\nimport global from './utils/global';\n\nfunction jarallaxVideo(jarallax = global.jarallax) {\n  if (typeof jarallax === 'undefined') {\n    return;\n  }\n\n  const Jarallax = jarallax.constructor;\n\n  // append video after when block will be visible.\n  const defOnScroll = Jarallax.prototype.onScroll;\n  Jarallax.prototype.onScroll = function () {\n    const self = this;\n\n    defOnScroll.apply(self);\n\n    const isReady =\n      !self.isVideoInserted &&\n      self.video &&\n      (!self.options.videoLazyLoading || self.isElementInViewport) &&\n      !self.options.disableVideo();\n\n    if (isReady) {\n      self.isVideoInserted = true;\n\n      self.video.getVideo((video) => {\n        const $parent = video.parentNode;\n        self.css(video, {\n          position: self.image.position,\n          top: '0px',\n          left: '0px',\n          right: '0px',\n          bottom: '0px',\n          width: '100%',\n          height: '100%',\n          maxWidth: 'none',\n          maxHeight: 'none',\n          pointerEvents: 'none',\n          transformStyle: 'preserve-3d',\n          backfaceVisibility: 'hidden',\n          margin: 0,\n          zIndex: -1,\n        });\n        self.$video = video;\n\n        // add Poster attribute to self-hosted video\n        if (self.video.type === 'local') {\n          if (self.image.src) {\n            self.$video.setAttribute('poster', self.image.src);\n          } else if (\n            self.image.$item &&\n            self.image.$item.tagName === 'IMG' &&\n            self.image.$item.src\n          ) {\n            self.$video.setAttribute('poster', self.image.$item.src);\n          }\n        }\n\n        // add classname to video element\n        if (self.options.videoClass) {\n          self.$video.setAttribute(\n            'class',\n            `${self.options.videoClass} ${self.options.videoClass}-${self.video.type}`\n          );\n        }\n\n        // insert video tag\n        self.image.$container.appendChild(video);\n\n        // remove parent video element (created by VideoWorker)\n        $parent.parentNode.removeChild($parent);\n\n        // call onVideoInsert event\n        if (self.options.onVideoInsert) {\n          self.options.onVideoInsert.call(self);\n        }\n      });\n    }\n  };\n\n  // cover video\n  const defCoverImage = Jarallax.prototype.coverImage;\n  Jarallax.prototype.coverImage = function () {\n    const self = this;\n    const imageData = defCoverImage.apply(self);\n    const node = self.image.$item ? self.image.$item.nodeName : false;\n\n    if (imageData && self.video && node && (node === 'IFRAME' || node === 'VIDEO')) {\n      let h = imageData.image.height;\n      let w = (h * self.image.width) / self.image.height;\n      let ml = (imageData.container.width - w) / 2;\n      let mt = imageData.image.marginTop;\n\n      if (imageData.container.width > w) {\n        w = imageData.container.width;\n        h = (w * self.image.height) / self.image.width;\n        ml = 0;\n        mt += (imageData.image.height - h) / 2;\n      }\n\n      // add video height over than need to hide controls\n      if (node === 'IFRAME') {\n        h += 400;\n        mt -= 200;\n      }\n\n      self.css(self.$video, {\n        width: `${w}px`,\n        marginLeft: `${ml}px`,\n        height: `${h}px`,\n        marginTop: `${mt}px`,\n      });\n    }\n\n    return imageData;\n  };\n\n  // init video\n  const defInitImg = Jarallax.prototype.initImg;\n  Jarallax.prototype.initImg = function () {\n    const self = this;\n    const defaultResult = defInitImg.apply(self);\n\n    if (!self.options.videoSrc) {\n      self.options.videoSrc = self.$item.getAttribute('data-jarallax-video') || null;\n    }\n\n    if (self.options.videoSrc) {\n      self.defaultInitImgResult = defaultResult;\n      return true;\n    }\n\n    return defaultResult;\n  };\n\n  const defCanInitParallax = Jarallax.prototype.canInitParallax;\n  Jarallax.prototype.canInitParallax = function () {\n    const self = this;\n    let defaultResult = defCanInitParallax.apply(self);\n\n    if (!self.options.videoSrc) {\n      return defaultResult;\n    }\n\n    // Init video api\n    const video = new VideoWorker(self.options.videoSrc, {\n      autoplay: true,\n      loop: self.options.videoLoop,\n      showControls: false,\n      accessibilityHidden: true,\n      startTime: self.options.videoStartTime || 0,\n      endTime: self.options.videoEndTime || 0,\n      mute: !self.options.videoVolume,\n      volume: self.options.videoVolume || 0,\n    });\n\n    // call onVideoWorkerInit event\n    if (self.options.onVideoWorkerInit) {\n      self.options.onVideoWorkerInit.call(self, video);\n    }\n\n    function resetDefaultImage() {\n      if (self.image.$default_item) {\n        self.image.$item = self.image.$default_item;\n        self.image.$item.style.display = 'block';\n\n        // set image width and height\n        self.coverImage();\n        self.onScroll();\n      }\n    }\n\n    if (video.isValid()) {\n      // Force enable parallax.\n      // When the parallax disabled on mobile devices, we still need to display videos.\n      // https://github.com/nk-o/jarallax/issues/159\n      if (this.options.disableParallax()) {\n        defaultResult = true;\n        self.image.position = 'absolute';\n        self.options.type = 'scroll';\n        self.options.speed = 1;\n      }\n\n      // if parallax will not be inited, we can add thumbnail on background.\n      if (!defaultResult) {\n        if (!self.defaultInitImgResult) {\n          video.getImageURL((url) => {\n            // save default user styles\n            const curStyle = self.$item.getAttribute('style');\n            if (curStyle) {\n              self.$item.setAttribute('data-jarallax-original-styles', curStyle);\n            }\n\n            // set new background\n            self.css(self.$item, {\n              'background-image': `url(\"${url}\")`,\n              'background-position': 'center',\n              'background-size': 'cover',\n            });\n          });\n        }\n\n        // init video\n      } else {\n        video.on('ready', () => {\n          if (self.options.videoPlayOnlyVisible) {\n            const oldOnScroll = self.onScroll;\n            self.onScroll = function () {\n              oldOnScroll.apply(self);\n              if (\n                !self.videoError &&\n                (self.options.videoLoop || (!self.options.videoLoop && !self.videoEnded))\n              ) {\n                if (self.isVisible()) {\n                  video.play();\n                } else {\n                  video.pause();\n                }\n              }\n            };\n          } else {\n            video.play();\n          }\n        });\n        video.on('started', () => {\n          self.image.$default_item = self.image.$item;\n          self.image.$item = self.$video;\n\n          // set video width and height\n          self.image.width = self.video.videoWidth || 1280;\n          self.image.height = self.video.videoHeight || 720;\n          self.coverImage();\n          self.onScroll();\n\n          // hide image\n          if (self.image.$default_item) {\n            self.image.$default_item.style.display = 'none';\n          }\n        });\n\n        video.on('ended', () => {\n          self.videoEnded = true;\n\n          if (!self.options.videoLoop) {\n            // show default image if Loop disabled.\n            resetDefaultImage();\n          }\n        });\n        video.on('error', () => {\n          self.videoError = true;\n\n          // show default image if video loading error.\n          resetDefaultImage();\n        });\n\n        self.video = video;\n\n        // set image if not exists\n        if (!self.defaultInitImgResult) {\n          // set empty image on self-hosted video if not defined\n          self.image.src =\n            'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';\n\n          if (video.type !== 'local') {\n            video.getImageURL((url) => {\n              self.image.bgImage = `url(\"${url}\")`;\n              self.init();\n            });\n\n            return false;\n          }\n        }\n      }\n    }\n\n    return defaultResult;\n  };\n\n  // Destroy video parallax\n  const defDestroy = Jarallax.prototype.destroy;\n  Jarallax.prototype.destroy = function () {\n    const self = this;\n\n    if (self.image.$default_item) {\n      self.image.$item = self.image.$default_item;\n      delete self.image.$default_item;\n    }\n\n    defDestroy.apply(self);\n  };\n}\n\nexport default jarallaxVideo;\n","import global from '../utils/global';\n\nfunction jarallaxElement(jarallax = global.jarallax) {\n  // eslint-disable-next-line no-console\n  console.warn(\n    \"Jarallax Element extension is DEPRECATED, please, avoid using it. We recommend you look at something like `lax.js` library <https://github.com/alexfoxy/lax.js>. It is much more powerful and has a less code (in cases when you don't want to add parallax backgrounds).\"\n  );\n\n  if (typeof jarallax === 'undefined') {\n    return;\n  }\n\n  const Jarallax = jarallax.constructor;\n\n  // redefine default methods\n  [\n    'initImg',\n    'canInitParallax',\n    'init',\n    'destroy',\n    'coverImage',\n    'isVisible',\n    'onScroll',\n    'onResize',\n  ].forEach((key) => {\n    const def = Jarallax.prototype[key];\n    Jarallax.prototype[key] = function (...args) {\n      const self = this;\n\n      if (key === 'initImg' && self.$item.getAttribute('data-jarallax-element') !== null) {\n        self.options.type = 'element';\n        self.pureOptions.speed = self.$item.getAttribute('data-jarallax-element') || '100';\n      }\n      if (self.options.type !== 'element') {\n        return def.apply(self, args);\n      }\n\n      self.pureOptions.threshold = self.$item.getAttribute('data-threshold') || '';\n\n      switch (key) {\n        case 'init': {\n          const speedArr = `${self.pureOptions.speed}`.split(' ');\n          self.options.speed = self.pureOptions.speed || 0;\n          self.options.speedY = speedArr[0] ? parseFloat(speedArr[0]) : 0;\n          self.options.speedX = speedArr[1] ? parseFloat(speedArr[1]) : 0;\n\n          const thresholdArr = self.pureOptions.threshold.split(' ');\n          self.options.thresholdY = thresholdArr[0] ? parseFloat(thresholdArr[0]) : null;\n          self.options.thresholdX = thresholdArr[1] ? parseFloat(thresholdArr[1]) : null;\n\n          def.apply(self, args);\n\n          // restore background image if available.\n          const originalStylesTag = self.$item.getAttribute('data-jarallax-original-styles');\n          if (originalStylesTag) {\n            self.$item.setAttribute('style', originalStylesTag);\n          }\n\n          return true;\n        }\n        case 'onResize': {\n          const defTransform = self.css(self.$item, 'transform');\n          self.css(self.$item, { transform: '' });\n          const rect = self.$item.getBoundingClientRect();\n          self.itemData = {\n            width: rect.width,\n            height: rect.height,\n            y: rect.top + self.getWindowData().y,\n            x: rect.left,\n          };\n          self.css(self.$item, { transform: defTransform });\n          break;\n        }\n        case 'onScroll': {\n          const wnd = self.getWindowData();\n          const centerPercent =\n            (wnd.y + wnd.height / 2 - self.itemData.y - self.itemData.height / 2) /\n            (wnd.height / 2);\n          const moveY = centerPercent * self.options.speedY;\n          const moveX = centerPercent * self.options.speedX;\n          let my = moveY;\n          let mx = moveX;\n          if (self.options.thresholdY !== null && moveY > self.options.thresholdY) my = 0;\n          if (self.options.thresholdX !== null && moveX > self.options.thresholdX) mx = 0;\n          self.css(self.$item, { transform: `translate3d(${mx}px,${my}px,0)` });\n          break;\n        }\n        case 'initImg':\n        case 'isVisible':\n        case 'coverImage':\n          return true;\n        // no default\n      }\n      return def.apply(self, args);\n    };\n  });\n}\n\nexport default jarallaxElement;\n","import jarallaxLib from './core';\nimport jarallaxVideoExt from './ext-video';\nimport jarallaxElementExt from './deprecated/ext-element';\n\nexport const jarallax = jarallaxLib;\n\nexport const jarallaxVideo = function jarallaxVideo() {\n  return jarallaxVideoExt(jarallax);\n};\n\nexport const jarallaxElement = function jarallaxElement() {\n  return jarallaxElementExt(jarallax);\n};\n"],"names":["$4f4d636ec052f8d7$var$wndW","$4f4d636ec052f8d7$var$wndH","$4f4d636ec052f8d7$var$$deviceHelper","callback","$parcel$global","globalThis","$4f4d636ec052f8d7$var$defaults$1","type","speed","containerClass","imgSrc","imgElement","imgSize","imgPosition","imgRepeat","keepImg","elementInViewport","zIndex","disableParallax","onScroll","onInit","onDestroy","onCoverImage","videoClass","videoSrc","videoStartTime","videoEndTime","videoVolume","videoLoop","videoPlayOnlyVisible","videoLazyLoading","disableVideo","onVideoInsert","onVideoWorkerInit","$4f4d636ec052f8d7$var$global$2","window","self","navigator","$4f4d636ec052f8d7$var$navigator$1","$4f4d636ec052f8d7$var$mobileAgent","test","userAgent","$4f4d636ec052f8d7$var$updateWindowHeight","innerWidth","document","documentElement","clientWidth","body","createElement","style","cssText","appendChild","clientHeight","innerHeight","$4f4d636ec052f8d7$var$getWindowSize","width","height","addEventListener","readyState","capture","once","passive","$4f4d636ec052f8d7$var$jarallaxList","$4f4d636ec052f8d7$var$updateParallax","length","wndW","wndH","forEach","data","k","instance","oldData","isVisible","clientRect","$item","getBoundingClientRect","newData","top","bottom","isResized","isScrolled","onResize","requestAnimationFrame","$4f4d636ec052f8d7$var$visibilityObserver","IntersectionObserver","entries","entry","target","jarallax","isElementInViewport","isIntersecting","rootMargin","$4f4d636ec052f8d7$var$navigator","$4f4d636ec052f8d7$var$instanceID","$4f4d636ec052f8d7$var$Jarallax","constructor","item","userOptions","self1","instanceID","defaults","dataOptions","dataset","pureDataOptions","Object","keys","key","lowerCaseOption","substr","toLowerCase","options","extend","pureOptions","Math","min","max","parseFloat","RegExp","disableParallaxRegexp","disableVideoRegexp","elementInVP","Element","image","src","$container","useImgTag","position","initImg","canInitParallax","init","css","el","styles","getComputedStyle","getPropertyValue","out","args","$4f4d636ec052f8d7$var$extend$1","i","getWindowData","y","scrollTop","$imgElement","querySelector","Image","cloneNode","$itemParent","parentNode","bgImage","containerStyles","left","overflow","imageStyles","pointerEvents","transformStyle","backfaceVisibility","curStyle","getAttribute","setAttribute","curImgStyle","$parents","$4f4d636ec052f8d7$var$getParents","elem","parents","parentElement","nodeType","push","filter","parentTransform","transform","overflowRegex","call","observe","destroy","splice","unobserve","originalStylesTag","removeAttribute","originalStylesImgTag","removeChild","coverImage","rect","contH","isScroll","scrollDist","resultH","resultMT","abs","parallaxScrollDistance","marginTop","container","force","contT","beforeTopEnd","afterTop","beforeBottom","beforeBottomEnd","fromViewportCenter","visiblePercent","opacity","scale","positionY","section","beforeTop","afterBottom","$4f4d636ec052f8d7$var$jarallax$1","items","ret","HTMLElement","nodeName","len","apply","$b63be9b0371e788c$var$slowJarallaxElements","getElementsByClassName","$b63be9b0371e788c$var$fastJarallaxElements","$b63be9b0371e788c$var$menuBtn","getElementById","$b63be9b0371e788c$var$navCtn","classList","toggle","win","global","getParents","ready","mobileAgent","isMobile","$deviceHelper","getDeviceHeight","updateWindowHeight","domReady","getWindowSize","jarallaxList","updateParallax","visibilityObserver","addObserver","removeObserver","Jarallax","jarallaxVideo","defOnScroll","prototype","isReady","isVideoInserted","video","getVideo","$parent","right","maxWidth","maxHeight","margin","$video","tagName","defCoverImage","imageData","node","h","w","ml","mt","marginLeft","defInitImg","defaultResult","defaultInitImgResult","defCanInitParallax","VideoWorker","autoplay","loop","showControls","accessibilityHidden","startTime","endTime","mute","volume","resetDefaultImage","$default_item","display","isValid","getImageURL","url","on","oldOnScroll","videoError","videoEnded","play","pause","videoWidth","videoHeight","defDestroy","jarallaxElement","console","warn","def","threshold","speedArr","split","speedY","speedX","thresholdArr","thresholdY","thresholdX","defTransform","itemData","x","wnd","centerPercent","moveY","moveX","my","mx","jarallaxLib","jarallaxVideoExt","jarallaxElementExt"],"version":3,"file":"index.e6e5579d.js.map"}